# 새롭게 알게된 점
## Container vs Image

- 이미지는 컨테이너의 블루프린트, 코드와 애플리케이션 포함 템플릿
- 컨테이너는 이미지를 기반으로 실행되는 소프트웨어 유닛 인스턴스
- 하나의 동일한 이미지를 기반으로 하는 여러 컨테이너 실행 가능

## 컨테이너 실행 1.도커허브 공식이미지

> 베이스 이미지 (ex:node) 사용

로컬에서 이미지 찾을수 없으면, 도커허브에서 'node' 이미지를 가지고와서 로컬에 다운로드 후 이를 기반으로 하는 컨테이너 생성

> 단순 docker run node 만 한다면?

도커가 생성한 모든 컨테이너의 status를 보면 아무것도 실행되지 않은 상태.

실행이 되어도 로컬 통신과 컨테이너는 격리된 채 실행된다.

외부와 노출이 되지 않아서 내부 호스팅 머신으로 대화형세션(인터랙티브 모드) 필요.

> docker run -it node

터미널로 들어가서 컨테이너 및 컨테이너에 실행중인 노드와 상호작용 가능.

컨테이너가 실행 된다는건 로컬에 있는 노드와 다른 버전의 노드를 도커에서 실행가능한 상황

**## 컨테이너 실행2.커스텀 이미지**

> dockefile 생성

자체 이미지를 빌드할때 실행하는 도커 명령

`FROM` 운영체제 레이어(시스템에 있거나 도커허브에 있는 베이스 이미지)

`COPY` <컨테이너, 이미지 외부 경로> <이미지 내부 경로>

`RUN` npm install

`WORKDIR` /app

- 기본적으로 파일 시스템의 root 폴더에서 도커명령 실행
- 작업디렉토리 변경하면 여기 기준으로 도커명령 실행

`CMD` 명령어 이미지가 생성될떄 실행되지 않고, 이미지 기반을 컨테이너가 시작될때 실행

`EXPOSE` 80

- 컨테이너 내부(80포트)에서만 수신대기중.
- 그래서 외부에서 접근을 할수 없는 상황.
- 특정 로컬 시스템에 특정 포트를 노출하고 싶다는걸 알림
- 사실 문서화,`docker run -p 외부포트:내부포트` 로 실제로 연결

> dockerfile로 이미지 빌드

`docker build .` : 도커파일이랑 동일한 경로에 있을때 이미지 빌드

> 컨테이너 실행

`docker run [이미지id]` : 빌드한 이미지를 기반으로 컨테이너 실행

`docker run -p 3000:80 [이미지id]` : 외부3000포트에서 컨테이너내부80포트에 접근해서 실행

> 컨테이너 접속

http://localhost:3000 에 접근하면 컨테이너로 띄운 노드서버 접속 가능

### 이미지와 컨테이너가 동작하는 방법

> 이미지와 레이어

- 이미지 위에 작은 레이어로 컨테이너 실행
- 이미지에 저장된 코드와 환경을 사용해서 애플리케이션 실행
- 동일한 애플리케이션을 실행하는 여러 컨테이너가 시스템에서 매우 적은 공간 차이, 분리되어 실행

> 코드에 변경사항이 생기면 다시 이미지를 빌드해야한다.

- 컨테이너를 재시작한다고 해도 변경사항이 적용되지 않음.
- 이미지를 만들떄 파일의 스냅샷이 생겨서 컨테이너 재실행을 해도 이전의 스냅샷 사용하기 떄문에

> 레이어를 캐시한다

- 다시 빌드할때는 캐시된 레이어 덕분에 빌드속도가 조금더 빠르다
- dockerfile로 이미지 구축을 위한 한줄한줄 명령어는 캐시가능한 레이어

> 여러 컨테이너가 동일한 이미지를 기반으로 하지만, 서로 완전히 격리된 상태

- 같은 이미지로 여러 컨테이너를 만들수 있음
- 하지만 그 컨테이너들은 완전히 격리되서 실행되고 공유데이터가 없다.
- 각 컨테이너들은 독립적으로 실행된다
- 각 컨테이너는 새 컨테이너나 새 파일로 복사하는게 아니라 이미 저장된 환경을 사용한다.그 위에 레이어를 추가할 뿐
- 하나의 이미지와 두개의 컨테이너가 있을경우, 이미지와 컨테이너에 한번만 존재하고 코드는 이미지 활용

### 도커 명령어

`docker ps`  : 실행중인 컨테이너 표시

- -a : 중지된 컨테이너를 포함해서 모든 컨테이너 표시
- —no-trunc : docker ps 하고 뒤에 commnads가 짤리는데 전체 다 보고싶을때

> docker start vs docker run

- `docker start` : detached 모드 (디폴트)

중지된 컨테이너도 다시 실행할 수 있음

콘솔에 출력되는 로그처럼 컨테이너의 출력결과를 볼수 '없음'

a 옵션 : attatched 모드 `docker start -a`

- docker run : attached 모드 (디폴트)

이미지를 기반으로 새로운 컨테이너 실행

컨테이너의 출력결과를 볼수 '있음'

d 옵션 : detached 모드 `docker run -d`

> 실행중인 컨테이너의 로그를 보는 방법

- docker attach [컨테이너이름]

컨테이너로 연결해서 터미널에 로그가 보임

- docker logs [컨테이너이름]

컨테이너에 출력된 과거 로그들까지 볼수 있음

` docker logs -f [컨테이너이름] `: follow 모드 옵션으로 로그 수신대기

> 인터랙티브 모드

- `docker run -it`

-it 옵션이 없다면, 컨테이너로 실행중인 애플리케이션에 어떤것도 입력받을수가 없어서 상호작용할수가 없음

-i : interactive mode : 인터랙티브 모드

-t: terminal : 컨테이너에 의해 노출되는 터미널 획득

- `docker start -a -i`

attatched 모드 옵션으로 출력결과 보고,

interaction 모드로 입력결과 받고 start

`docker rm [컨테이너ID]`

컨테이너 삭제 (단,실행중인 컨테이너는 삭제할 수 없음)

`docker rmi [이미지ID]`

이미지 삭제 (단, 실행/중지된 컨테이너에 속한 이미지는 삭제할수 없음)

`docker prune -a`

사용되지 않은 이미지 (a옵션:all)제거

`docker run --rm`

컨테이너가 중지 되면 항상 컨테이너도 제거되도록 실행

`docker image inspect [이미지ID]` 이미지 구성정보 확인

- Created: 이미지가 생성된 시간
- ContainerConfig : 노출될포트, 환경변수, 도커버전, 운영제체 등

`docker cp [컨테이너ID]:컨테이너경로  로컬경로`

컨테이너 안에 있는 파일을 로컬 경로로 파일복사 (로그파일 사용)

> 컨테이너 이름과 이미지 태그

- `docker run --name [이름]`

커스텀이름 지정해서 컨테이너 실행

원래는 이름이나 ID를 자동으로 할당하는데, 커스텀 이름 지정하면 기억하기 편함

- `docker build -t 이미지이름:tag`

일반적인 이미지 그룹 뒤에 특정버전, 특정구성을 사용할 수 있는 이미지 이름 옵션

이미지와 태그를 결합하면 고유식별자가 된다.

**### 이미지 공유하기**

1.도커파일 공유하기

직접 도커파일 가지고 로컬에서 이미지 빌드, 컨테이너 실행

대신 주변 파일이나 폴더 구성을 직접 해야함

2.빌드된 전체 이미지 공유

이미지를 다운로드하기만 하면 컨테이너 실행가능

> 어디에서 다운로드를? Docker Hub vs Private Registry

- 도커허브는 공식 도커 이미지 레지스트리 (public)
- private 레지스트리는 공개범위 설정 가능

> 어떻게 공유하는가? `docker push [사용자이름/이미지이름]`

- 대신 [사용자이름/이미지이름] 으로 이미지 빌드해서 도커허브에 푸쉬
- docker login : 내 계정의 레지스트리에 나만 접근할 수 있도록 로그인
- 전체 이미지가 아닌 추가정보만 푸쉬함

> 어떻게 다운로드하는가? `docker pull [사용자이름/이미지이름]`

- 도커허브 레지스트리에 push한 이름으로 풀
- 도커허브는 public이라서 아무나 풀 할 수 있음, 푸쉬할때처럼 로그인 필요없음
- docker run은 로컬에 이미지가 없으면 자동으로 최신 이미지 풀
- 로컬에 이미지가 있다면 최신 버전인지 아닌지 상관없이 그냥 그 이미지로 사용