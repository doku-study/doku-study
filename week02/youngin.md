# 2주차: Docker 이미지 & 컨테이너: 코어 빌딩 블록

## 이미지 & 컨테이너

- 이미지: 컨테이너를 위한 템플릿이자 청사진.
  - 애플리케이션 코드 및 이를 실행하기 위한 도구와 환경이 정의되어 있음.
  - 한 번 빌드된 이후로 변경사항이 생기면 다시 빌드해야 함.
- 컨테이너: 실행 중인 소프트웨어
  - 이미지 하나를 인스턴스화 한 것.
  - 하나의 이미지로 여러개의 컨테이너를 만들어 실행할 수 있음.
  - 보통 미리 만들어진 베이스 이미지에 커스텀

## Docker Hub

- 공유 도커 이미지 저장소
  - `docker run <이미지명>` 명령어 입력 시 로컬 환경에 이미지가 존재하지 않으면 docker hub 에서 이미지를 찾는다.
- 이미지를 push, pull 할 수 있음.

## Dockerfile 로 자체 이미지 빌드하기

### `WORKDIR`: 작업 폴더 지정

- Dockerfile 의 모든 명령어가 실행되는 기본 위치는 루트 폴더이다.
- `WORKDIR <디렉토리 경로>` 를 하면 해당 line 아래의 모든 명령어는 주어진 `<디렉토리 경로>`에서 실행된다.

- 따라서 아래 두 Dockerfile은 같은 의미를 갖는다.

```docker
FROM node
WORKDIR /app
COPY . ./
RUN npm install
```

```docker
FROM node
WORKDIR /app
COPY . /app
RUN npm install
```

### `CMD`, `RUN`: 명령어 실행

- 차이점
  - `RUN`: 이미지를 빌드할 때마다 호출됨
    - 명령어를 그대로 작성. 예) `RUN npm install`
  - `CMD`: 빌드한 이미지로 컨테이너를 실행할 때마다 호출됨
    - 배열을 전달함. 예) `CMD ["node", "server.js"]`
- 따라서 도커 파일을 사용해 이미지를 빌드하는 과정에서는 `RUN`을, 마지막으로 애플리케이션을 실행시키기 위해서는 `CMD` 를 쓴다.

### `EXPOSE`: 컨테이너의 포트 노출하기

- 컨테이너 자체 네트워크에서 특정 포트를 호스트에게 노출한다고 설정해야 함. 그렇지 않으면 컨테이너 내부 네트워크에서만 놀게 된다.
- 하지만 도커 파일에 이걸 적어주는건 단순 documentation 차원에서 적는 것이고, 실제로 노출시키려면 아래 명령어로 컨테이너를 실행해야 함.

```
docker run -p <호스트 포트>:<컨테이너 포트> <이미지명>
```

## Layered Architecture

### 이미지 레이어

- 도커파일의 명령어 한 줄은 모두 레이어 하나가 됨.
  - 도커는 각 명령어에 대한 캐싱을 적용함.
- 이미지 빌드 시점에서 각 명령어를 실행할 필요가 없다고 생각되면 캐싱된 것을 그대로 사용
  - 만약 한 레이어에서 변경이 일어나면 그 이후로 이어지는 모든 레이어에 대한 캐시를 버리고 새롭게 명령어를 수행함.
    - 따라서 변경될 가능성이 적은 명령일수록 먼저 적는게 유리함.
      - 예) 노드 서버를 실행한다고 하면 아래 순서가 바람직하다.
        1. package.json 복사
        2. npm install 수행
        3. 소스코드 복사
- 이미지 레이어는 read-only

### 컨테이너 레이어

- 컨테이너는 이미지 레이어 위에 컨테이너 레이어를 추가함.
  - 도커파일 마지막줄에 적는 `CMD` 명령어는 이미지 레이어가 아닌 컨테이너 레이어에 위치한다.

## 컨테이너 실행

### 실행 모드

- Attached: 컨테이너의 출력 결과를 수신
  - `docker run` 으로 실행 시 attached 모드가 기본값
- Detached: 수신하지 않음
  - `docker start` 로 실행 시 detached 모드가 기본값
