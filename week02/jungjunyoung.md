## 이미지와 컨테이너

* 이미지는 템플릿, 컨테이너의 블루프린트

* 이미지 하나를 가지고 복수의 컨테이너를 생성함

* 컨테이너는 이미지의 구체적인 실행 인스턴스



<br />

## 외부(사전 빌드된) 이미지의 사용 및 실행

도커로 실행한 프로세스는 외부(사용자 컴퓨터)와는 독립적인 환경을 가진다.

모든 도커 프로세스를 다음 명령어로 확인할 수 있다. (-a 옵션을 빼면 실행중인 프로세스만 표시됨)

```shell
docker ps -a
```



도커로 node 이미지를 실행(컨테이너를 생성) 하기 위해서는 아래 명령어를 입력한다.

```shell
docker run node
```

그러나 노드를 실행하자마자 종료되는 것을 알 수 있는데, 이것은 인터랙티브 모드로 실행하지 않았기 때문이다.

따라서 -it 옵션을 붙여서 인터랙티브 모드로 실행해보자.



```shell
docker run -it node
```



이렇게 실행된 노드는, 앞서 서술했듯 독립된 nodeJS 환경을 가지므로, 사용자 PC 의 노드 버전과 관련이 없다.



<br />

## DockerFile 을 사용하여 자체 이미지 빌드하기

위에서는 외부 이미지를 사용하는 경우를 살펴봤으나, 현실에서는 이미지를 직접 생성해서 사용한다.

이번에는 직접 이미지를 생성해서 Node 를 띄워보자.

이미지를 생성하기 위해서는, Dockerfile 을 작성해야 한다. (아래 코드는 80 포트를 열어둔 노드 기반 서버 코드가 있다고 가정)

```dockerfile
# Dockerfile

# node 베이스 이미지 사용
FROM node

# 이미지 내부의 /app 이라는 디렉토리를 작업 디렉토리로 사용함. RUN 과 COPY 가 영향을 받음.
WORKDIR /app

# Dockerfile 이 위치한 곳의 모든 디렉토리, 파일을 /app 이라는 디렉토리 내부로 복사함
COPY . /app

# 이미지를 빌드할 때 실행할 명령어는 RUN 키워드를 사용함
RUN npm install

# 이미지를 기반으로 컨테이너가 시작될 때, 컨테이너가 노출했으면 하는 포트를 명시 
# ( 이는 단순히 문서화 목적으로 작성하는 것으로, 아래 구문을 추가해도 실제로 컨테이너의 80 포트가 expose 되지는 않음.
# 실제로 80 포트를 expose 하기 위해서는 컨테이너를 시작할 때 -p 옵션을 명시해야 함 자세한 실행방법은 후술)
EXPOSE 80

# 이미지를 기반으로 컨테이너가 시작될때 실행할 명령어는 CMD 키워드를 사용함
# CMD 구문이 없는 경우, 베이스 이미지가 실행되며, 베이스 이미지가 없는 경우 에러가 발생함
CMD ["node", "server.js"]
```



Dockerfile 을 작성했으면, Dockerfile 이 위치한 디렉토리에서 아래 명령어를 입력하여 이미지를 빌드해보자.

```shell
docker build .
```



빌드가 끝나면, `docker images` 명령어로 이미지 목록을 볼 수 있다.

```
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
<none>       <none>    b3f34122ee43   6 minutes ago   1.1GB
```



이미지 ID 를 기반으로, 컨테이너를 실행해보자.

```shell
docker run -p 3000:80 b3f34122ee43
```



-p 옵션은 도커를 실행하는 로컬 환경과 도커 내부 환경을 매핑해주는 역할을 한다. (로컬포트:도커 환경 내부에서 expose 하고자 하는 포트)

위의 명령어를 예시로 설명하면, 로컬의 3000 포트를 통해 도커 내부의 80 포트에 접근할 수 있다는 뜻이 된다.



<br />

## Dockerfile의 EXPOSE 구문은 문서일 뿐이다

한가지 재미있는 점은, Dockerfile 에 `EXPOSE 80 ` 구문을 넣어서 80 포트를 expose 하겠다고 명시하더라도, 컨테이너를 실행할 때 80 포트를 명시해줘야 한다는 것이다. 만약 아래 명령어로 컨테이너를 실행하면, 로컬에서는 80 포트에서 대기하고 있는 노드 서버에 연결할 방법이 없다.

```she
docker run -p 3000:70 b3f34122ee43
```

즉, 위의 Dockerfile 의 EXPOSE 부분 주석에서도 설명했지만 EXPOSE 구문은 문서의 역할만 할 뿐, 빌드되는 이미지와 실행되는 컨테이너에는 영향을 주지 않는다.

그럼에도 불구하고, Dockerfile 을 문서화 관점에서 바라본다면 `EXPOSE` 구문을 명시해주는 것이 바람직해 보인다.



<br />



## 이미지는 읽기 전용

지금까지 노드 서버 코드가 들어있는 이미지를 빌드하고, 이미지를 기반으로 컨테이너를 생성, 실행까지 해보았다.

여기서 만약 노드 서버 코드를 수정하고 싶으면 어떻게 해야할까?

이미지는 한 번 빌드되면 수정할 수 없다. 따라서 원본 코드를 수정했다고 하더라도, 이미지 내부의 코드는 이미지 빌드 시점의 코드가 그대로 남아 있다.

따라서 수정한 코드를 도커 컨테이너에 반영하기 위해서는, 소스코드를 수정하고, 도커 이미지 자체를 다시 빌드한 뒤, 다시 빌드된 이미지를 기반으로 컨테이너를 실행해야 한다.



<br />



## 이미지 레이어 이해하기

이전에 빌드한 이미지를 다시 빌드해보면, 전에 비해 빌드 속도가 훨씬 빠른 것을 체감할 수 있다.

이는 도커가 Dockerfile 에 명시된 각 구문에 대해 캐싱을 사용하기 때문이다.

즉, 각 구문의 실행 결과가 이전 빌드에서 실행된 해당 구문의 결과와 같다면, 해당 결과를 재사용하는 것이다.

이것을 레이어 기반 아키텍처 라고 부른다.

```dockerfile
# Dockerfile

# layer 1
FROM node

# layer 2
WORKDIR /app

# layer 3
COPY . /app

# layer 4
RUN npm install

# layer 5
EXPOSE 80
```

이러한 레이어 기반 아키텍처에서 중요한 것은, n 번째 레이어의 캐시가 히트되지 않는다면 그 이후의 모든 레이어도 캐시를 무시한다는 점이다.

예를 들어, 노드 서버 코드를 일부 수정하면 layer 3 번인  `COPY . /app `   구문의 실행 결과가 달라지므로, layer 4, 5 역시 캐시된 결과를 사용하지 않고 다시 실행된다.



<br />

## 이미지 레이어를 기반으로 이미지 빌드 최적화하기

package.json 과 npm 간의 관계를 이해하고 있는 개발자라면,

package.json 의 내용이 변하지 않는 이상 `npm install` 의 실행 결과 역시 변하지 않으리라는 것을 잘 알 것이다.

그러나 위 Dockerfile에서는 package.json이 아닌 노드 서버 코드만 변경되더라도 npm install 을 다시 실행해야 하는 비효율이 존재한다.

따라서, package.json 이 변경되었을 때에만 `npm install`이 실행되도록 아래와 같이 최적화해볼수 있다.

```docker
# Dockerfile

FROM node

WORKDIR /app

# package.json 을 이미지 내부의 app 디렉토리에 먼저 옮겨둔다.
COPY package.json /app

# 도커 내부의 app 디렉토리에 있는 package.json 을 기반으로 npm install 을 실행한다.
# 로컬의 노드 서버 코드가 수정된 후 실행중인 이미지 빌드라면, 이 구문(레이어) 까지는 캐시된 결과를 사용할 것이다.
RUN npm install

# 로컬의 모든 디렉토리와 파일을 app 폴더에 옮긴다.
# 로컬의 노드 서버 코드가 수정된 후 실행중인 이미지 빌드라면, 이 구문(레이어) 부터는 캐시된 결과를 사용하지 않을 것이다.
COPY . /app

EXPOSE 80

CMD ["node", "server.js"]
```

`RUN npm install` 이하의 모든 구문(레이어)들은 노드 서버 코드 변경과는 연관이 없으므로, 노드 서버 코드만을 변경할 때에는 항상 캐시된 결과를 사용할 것이라고 기대할 수 있다. 



<br />

## 이미지 & 컨테이너 삭제 기본

default 속성으로, 중지된 컨테이너는 삭제되지 않는다.

중지된 컨테이너는 `docker start 컨테이너이름` 으로 재시작할 수 있다.

해당 명령은 `docker run 컨테이너이름` 과 달리 default로 detached 모드로 실행되기 때문에, 터미널에 추가로 명령어를 입력할 수 있다.

detached 모드는 atached 모드와 달리 프로그램의 출력 결과(ex: console.log) 를 터미널에서 수신할 수 없으니 주의하자.



컨테이너 인스턴스가 없는 이미지를 삭제하는 방법은 다음과 같다.

```shell
docker rmi 이미지이름
```



컨테이너 인스턴스가 없는 모든 이미지는 다음 명령어로 삭제할 수 있다.

```shell
docker image prune
```



이러한 이미지를 삭제하는 데에는 해당 이미지를 베이스로 실행중이거나, 중지된 컨테이너가 없어야 한다는 제약조건이 있다.

따라서 이미지를 삭제하기 위해서는 컨테이너를 먼저 삭제해야 한다.



중지된 컨테이너를 삭제하는 방법은 다음과 같다.

```shell
docker rm 컨테이너이름 컨테이너이름2 컨테이너이름3
```

그러나 삭제하고자 하는 컨테이너가 여러개라면, 컨테이너 이름을 여러 개 나열해야 하므로 귀찮다.



<br />

## 모든 컨테이너 일괄 삭제

중지된 + 실행중인 모든 컨테이너를 삭제하는 방법을 먼저 알아보자. 아래 명령어는 모든 컨테이너를 ID 만 출력하는 quite 버전 명령어를 응용하여, 컨테이너를 강제로 삭제하는 명령어와 합쳐서 사용한다.

```shell
docker rm -f $(docker ps -qa)
```



<br />

## 컨테이너가 중지되면 자동 삭제되는 옵션

애초에 컨테이너가 실행되고 중지될때, 알아서 삭제되면 컨테이너를 일일이 삭제해줘야 하는 불편함 자체를 없앨 수 있다.

```shell
docker run -p 3000:80 --rm 이미지ID
```

--rm 옵션을 붙이면 컨테이너가 중지될때 해당 컨테이너를 자동으로 삭제한다.

​     

<br />

## 컨테이너, 이미지에 이름 부여

컨테이너를 실행할 때 원하는 이름을 부여할 수 있다. 컨테이너의 실행을 중지하거나, 다시 실행할 때 컨테이너의 이름을 사용하므로, 커스텀 이름을 사용함으로써 조금 더 편리해진다.

```shell
docker run -p 3000:80 --rm --name 컨테이너이름 이미지ID
```



이미지는 조금 다른 방식인 이름:태그를 사용한다. 형식은 `이름:태그`  이며, 태그는 해당 이미지의 여러 버전 등을 나타내기 위해 사용한다. 아래 코드를 보자.

```dockerfile
# Dockerfile

# 14라는 태그가 붙은 node 이미지를 사용하는 구문이다. 이 도커파일은 node 14 버전 이미지를 베이스로 한다.
FROM node:14
```



커스텀 이미지에 이름과 태그를 붙여서 빌드하는 방법은 다음과 같다.

```shell
docker build -t 이름:태그 .
```



이제 이름과 태그가 있는 커스텀 이미지를 베이스로, 이름이 있는 컨테이너를 실행해보자.

```shell
docker run -p 3000:80 --rm --name 컨테이너이름 이미지이름:이미지태그
```





<br />

## 이미지 공유하기

이미지를 가진 사람은 누구나 동일한 컨테이너를 생성할 수 있으므로, 우리는 컨테이너는 공유하지 않고, 이미지만을 공유한다.

이미지를 공유하는 방법은 크게 두 가지가 있다.



1. Dockerfile 을 공유하기
   * Dockerfile이 있으면 이미지를 빌드할 수 있다.
   * Dockerfile 외에도, 이미지를 빌드하는 데에 필요한 소스 코드 등이 필요할 수 있다.
2. 빌드된 이미지를 공유하기
   * Dockerfile로 빌드된 이미지 자체를 공유할 수 있다.
   * 빌드된 이미지 자체에 소스 코드 등이 이미 들어있으므로, 이미지 외에는 아무것도 필요하지 않다.



<br />

## 기타 팁

<br />

### 이미지 상세정보 조회

이미지에 대한 상세 정보를 볼 수 있는 명령어

```shell
docker image inspect 이미지ID
```

<br />



### 컨테이너에, 컨테이너로부터 파일 복사

실행 중인 컨테이너에 파일을 복사해 넣거나, 컨테이너로부터 로컬로 파일을 복사해올 수 있다.

컨테이너 -> 로컬

```shell
docker cp 컨테이너명:/파일path 로컬path
```

도커 내부의 로그 파일 등을 로컬로 가져와서 확인하는 일 등에 쓰일 수 있을 것 같다.

<br />

로컬 -> 컨테이너

```shell
docker cp 로컬path 컨테이너명:/파일path
```

이미 실행중인 컨테이너에 파일을 새로 복사해 넣는다는 것은, 이미지를 읽기 전용으로 사용하는 도커의 철학과 그다지 맞지 않는 작업이므로, 지양하는게 좋겠다.

<br />















