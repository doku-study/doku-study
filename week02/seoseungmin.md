

## 컨테이너 VS 이미지

- Docker Image
    - 애플리케이션을 실행하는데 필요한 모든 설정 명령, 모든 코드를 포함한 소프트웨어 패키지
    - 이미지는 컨테이너를 찍어내는 일종의 blueprint 역할을 함 (강의에선 dissolver라는 표현을 썼는데 잘 와닿진 않음)
    - 이미지는 파이썬의 클래스와 유사한 개념인 것 같다. 각각 컨테이너, 객체라는 인스턴스를 찍어내는 설계도라는 점

- Docker Container
    - 이미지를 실행한 인스턴스다. 이미지라는 blueprint를 실제로 실행시켜 작동하고 있는 상태


## 이미지 빌드

- 이미지는 Dockerfile로 빌드할 수도 있고, 이미 빌드되어 있는걸 사용할 수도 있음
- 공식 이미지 (도커 허브)
    - `node`라는 이미 빌드되어 있는 공식 이미지를 `docker run node`로 빌드
    - 이 이미지를 기반으로 하는 컨테이너를 생성 & 실행 할 수 있음
    - 실행 중인 컨테이너는 `docker ps -a`로 확인 가능
        - `ps`는 프로세스
        - `-a`는 도커가 생성한 모든 컨테이너, 프로세스가 표시됨
    - `node` 자체는 인터렉티브 쉘을 제공함. 이 기능을 컨테이너 위에서 사용하고 싶으면 `docker run -it node` 실행해야 함.
- custom image 빌드
    - 노드(Node.js)는 웹 개발을 위한 프레임워크로 그나마 내가 아는 Django와 비슷한 것이라고 생각됨 (css, js와 같은 서버 구성 요소가 있음)
        - 하려는 것: 이 노드 서버를 도커 위에서 실행&배포까지 하려고 함
    - 이 노드 패키지를 로컬에서 실행하려고 한다면, NodeJS.org에서 Node JS를 설치해야함
        - 노드 설치되면 `npm install` 실행시켜 `package.json`에 적힌 dependencies를 설치함
        - 종속 패키지 설치되면 `node server.js` 명령어로 서버 실행시킬 수 있음
    - 만약 도커 위에서 실행한다면?
        - `Dokcerfile`이라는 파일 필요 (VSC의 docker extensions 설치하면 dockerfile 작성하는데 보조 받을 수 있음)

## Dockerfile        
        
- `FROM {image-you-want}`: 내 시스템이나 도커 허브에 존재하는 이미지를 기반으로 한다는 것
- 다음으론 로컬에 있는 어떤 파일이 이미지에 들어가야 할지 알려줘야 함
    - `COPY . /app`: 첫번째는 Dockerfile와 같은 경로라는 의미. 두번째 dot은 이미지 내부의 경로를 가리킴. 컨테이너 내부의 `/app`에 복사됨
    - *모든 이미지, 모든 컨테이너에는 자체 내부 파일 시스템이 있음*
- 다음으론 로컬에서 했던 것과 같이 `npm install` 실행해서 종속되어 있는 패키지를 설치해야 함
    - `RUN npm install`: 이 명령어는 루트 경로에서 실행됨. 코드를 복사한 경로와 마찬가지로 `/app`에서 실행되게 하려면 `WORKDIR /app`이 필요. 이걸로 기본 경로가 `/app`이 됐으나 `COPY . ./`으로 할 수 있음
- 마지막 명령은 모든 작업이 완료되면 서버를 실행하라는 것. `RUN node server.js`가 될 수 있을 것 같지만, dockerfile에서 이렇게 적어버리면 이미지가 빌드될 때 마다 서버가 실행되는셈.
    - 이미지는 실행시키는 것이 아니라, 이걸 기반으로 컨테이너를 찍어내서 컨테이너를 실행시키는 것
    - `CMD ['node', 'server.js']`: 컨테이너 시작될 때 실행하는 것. 배열을 전달해야 함
- 이 노드 웹 서버는 80 포트에서 수신 대기함.
    - 도커 컨테이너는 격리되어 있음. 자체 내부 네트워크가 있다는 것. (로컬 호스트와 다르다는 것)
    - 이 컨테이너 시작될 때 로컬 시스템에 특정 포트 노출한다는 명령어 필요 `EXPOSE 80`

- Dockerfile 작성했으면 이걸 실행시켜야 함
    - `docker build {dockerfile 경로}`로 이미지 빌드 (`docker run`은 이걸 실행하는 셈.. *애초에 실행할 수 없게 만들면 되지 않나)*
    - 생성되면 `docker run {생성된 컨테이너 ID}` 실행. 그럼 완료되지 않고 계속 실행 중. 왜? 위에서 설정한 CMD가 노드 서버를 실행 중이기 때문
- localhost:80 접속해도 노드 서버 표시안 됨. 왜? `EXPOSE 80` 자체로는 아무것도 못함.
    - 컨테이너 실행 할 때 `-p` 플래그 추가해야 함. publish 한다는 것. 다음에 액세스하려는 로컬 포트와 내부 도커 컨테이너 노출 포트를 `:`로 맞춰줌 -> `-p 3000:80` 과 같이.
    - 이제 `localhost:3000`을 로드하면 노드 서버 표시됨
    - *그냥 웹에서 도커 컨테이너 포트에 바로 접속할 수 있게 하는건 안되나?*

## 이미지는 레이어 기반 아키텍쳐

- 로컬의 노드 코드를 변경한다면 이게 실행 중인 컨테이너 위의 노드 서버에서는 표시 안됨
    - 왜? 이미지 빌드할 때 시점이 중요. 복사한 시점에서 소스 코드 스냅샷을 땀
    - 그래서 코드를 변경했으면 `docker build .`로 이미지 다시 빌드해줘야 함
    - 번거롭겠지만 팩트... 그나마 효율적인 방법이 있긴한데 이건 나중에 소개해준다고 함
- Dockerfile은 레이어 기반 아키텍쳐의 좋은 예시
    - 레이어라는 개념 자체의 특징은 모듈성, 재사용성, 계층적 구성 등이 있음
    - Dockerfile에서 각 명령어는 도커 이미지를 구성하는 별도의 레이어를 생성함. 레이어의 특징 관점에서 dockerfile을 살펴보면
        - 재사용성: 이미지 빌드 시 각 레이어 결과를 캐시해서 이후 빌드 과정에서 변경되지 않은 레이어는 다시 빌드하지 않고 캐시된 결과를 사용함 (`Using Cache`라는 구문으로 확인 가능)
        - 계측정 구성: 각 단계는 이전 단계 결과 위에 구축됨. 명령어 순서가 중요함
    - *레이어는 왜 명령어 단위일까? 다른 단위였을 수는 없나?*
        - *잘은 모르겠지만 무엇을 빌드할 땐 명렁어가 순차적으로 실행되는 모습이 읽고 이해하기 쉽다고 함. 비단 dockerfile에만 해당하는 내용은 아닌듯*
        - Dockerfile 내의 명령어는 레이어 기반으로써 순서를 가짐. 그래서 n번째 명령어가 다시 빌드되었다면 n+1번째 명령어부터 쭉 다시 빌드됨
- 만약 `package.json`과 같이 변경할 일 없고, 한 번 설치하면 끝인 경우 dockerfile 상단 부분에 미리 빌드되게 해서 이미지 생성 속도를 높이는 방법도 있음
    - *정말 효과적으로 작성했다면 이미지 생성 속도가 그냥 로컬 반영과 크게 차이나지 않을 것 같기도 하다.*
- 소스 코드 변경 시 이미지 다시 빌드해야 하는 점은 확실히 번거로움. 이 부담을 좀 줄이기 위해 이런 레이어 기반 아키텍쳐가 필요했다고 이해됨.

***

- 가상환경과 달리 애플리케이션에 필요한 뼈대만 다루는 느낌이다
    - 다른 사람의 주피터 노트북 실행할 때 필요한건 결국 파이썬 프로그램와 패키지라고 할 수 있다. `FROM`에서 기본 프로그램을, `RUN requirements.txt`에서 필요한 패키지 설치를 한다고 볼 수 있지 않을까
    - 거기에 포트를 열어서 외부에서 컨테이너 접속할 수 있게 해주는 기능. 대체로 웹이겠지만..
    - 이미지가 실체화(?)된 Dockerfile이 핵심인걸까

- 컨테이너는 이미지 위에 추가된 얇은 레이어에 불과함. 이 얇은 레이어가 있어 실행될 수 있는 것 `CMD`
    - 물리적으로 복사된건가? 헷갈리네

***

## 직접 실행

- 실행 중인 컨테이너를 종료할 때 `control + C`로 안됨. desktop에서 GUI로 꺼줘야 함. 뭘 잘못하고 있는걸까
- `docker build .` 후 `docker ps -a`로 해도 컨테이너 ID 확인 안됨. desktop에서는 확인 가능함
- desktop에서 컨테이너 ID 복사하는데 너무 길어 이상함. '2f284f466ba20f1f68420a7f8cb206885c9b2eeafe91aa3fa7a2104c017fc19b'
    - 원래 이 정도인가..? 여튼 이걸로 `docker run -p 3000:80 {container id}`하니 잘 실행됨
    - 고유식별 가능한 정도로만 prefix 떼서 사용해도 됨. 강의 팁 부분에 적혀있었네
- 처음에 `FROM node` 구문에서 도커 허브에 있는 공식 node 이미지를 미리 빌드해놓지 않아서 대문자 N으로 해야하나 고민했는데 저 방식이 맞는듯
- `docker build` 할 때 대그를 지정 안하면 `docker run`에서 어떤 이미지를 사용해서 컨테이너 생성하는지 컴퓨터가 모르지 않나..?
    - 강의에선 build하면 마지막 문구에 출력되는 ID를 복사해서 사용. 만약 이걸 놓쳤다면 `docker images`로 생성된 이미지 ID 확인 가능




***

## 이미지, 컨테이너 관리

- `docker --help`
- `docker ps` : 실행 중인 컨테이너. `-a`를 추가하면 실행 중이지 않은 것까지 표시
- `docker run` : 새 컨테이너 시작
    - 컨테이너를 foreground 에서 실행시킴
    - attached 모드라고 함
    - 컨테이너 출력 결과를 확인할 수 있음
- `docker start {container names}`: 기존 컨테이너를 다시 시작
    - 디폴트로 백그라운드에서 실행 시킴
    - detached 모드라고 함
    - attached 모드에서 시작하고 싶으면 `-a` 태그 추가
- `docker run -d {image id}` : 컨테이너를 백그라운드에서 시작
    - `docker attach {container names}`: 컨테이너를 attached 시켜 출력 결과 다시 받음
- `docker logs {ccntainer name}`: 컨테이너에 출력되는 로그를 가져옴
    - `docker logs -f {container name}`: 계속 로그를 출력하도록 수신 대기
- `docker stop {container name}`: 컨테이너 중지


## python과 도커

- 웹서버 구축 시에만 도커를 사용하는게 아니라 다양한 경우에도 사용될 수 있음
- 강의 예제 py의 경우 `input` 함수로 인자값 받는 것이 있어 인터렉티브 모드 필요. 
    - `-i`: 컨테이너에 무언가 입력할 수 있음
    - `-t`: 터미널 생성
    - `docker run -it {image id}`
    `docker start -a -i {container name}`
- **출력 결과 수신 또는 입력을 제공하기 위해 여러 태그가 제공되지 `--help`로 잘 확인해보는 습관 가질 것**


## 이미지, 컨테이너 삭제

- 그동안 dekstop UI 에서 삭제했는데 CLI에서 삭제하는 방법
- `docker rm {container name}`: 제거 전 컨테이너 `stop` 시켜야 함.
- `docker rmi` : 이미지 제거. 명령어 실행하면 이미지 내부의 모든 레이어를 삭제해서 여러 줄이 출력됨
- `docker run --rm {image id}`: 컨테이너 시작하되 컨테이너 중지하면 삭제되게. 필요한 경우메나 쓰면 될듯
- 

## 기타

- `docker image inspect {image id}`: 이미지와 관련된 여러 메타 데이터를 보여줌
- `docker cp {local copy path} {container name}:/{paste path}` : 로컬 파일, 폴더를 컨테이너에 복사
    - 순서 바꾸면 컨테이너 파일, 폴더를 로컬에 복사함
    - 유용할 것 같지만 버전 관리도 안될테고, 오류 발생하기 쉽다. 더 나은 방법이 있다고 함

## 이미지, 컨테이너 네이밍

- `docker run --name {container name you want}`: 컨테이너에 이름 붙여서 생성&실행 할 수 있음
- `docker build -t {name:tag} .`: 이미지의 이름과 태그를 지정해서 빌드함
    - name:tag 라는 두 요소로 구성되어 있는데, 전자는 그룹, 후자는 그룹 내 위치를 나타내는 역할
    - `node:14` 와 같이 이미지 이름과 태그를 지정해서 빌드할 수 있음
    - 도커 허브에 보면 공식 이미지에도 다양한 태그가 존재함. 이 태그로 특정 버전, 특정 구선, 슬림한 구성을 사용할 수 있음.
    - 내가 작성한 dockerfile의 `FROM python:3.10-slim` 여기서 `3.10-slim`이 태그였구나
- 위에서 이미지 이름,태그 지정했으면 `docker run --name {container name you want} {iamge name:tag}`로 원하는 이미지로부터 컨테이너의 이름을 지정해서 생성&실행 할 수 있음

## 이미지 공유

- 도커 사용하는 중요한 이유 중 하나는 다른 사람들과 이미지 공유하는데 있음. 어떻게?
- 이미지와 컨테이너를 다른 사람과 공유, 다른 컴퓨터에 공유하는 방법 필요
- 컨테이너를 공유하는게 아닌 이미지를 공유하는 것

- Dockerfile을 공유하는 방법
    - 가장 쉽게 생각할 수 있는 방법
- 빌드된 이미지를 공유하는 방법
    - 이미지를 다운로드해서 컨테이너 run 시키면 됨. 빌드 단계가 필요 없음
    - 이게 일반적인 방법이라고 함

- 이미지 푸쉬
    - docker hub: 무료. 공식 도커 이미지 레지스트리 사용하는 방법. 
    - private registry: 사설 도커 이미지 공급업체 느낌. 이런 서비스가 수천개라고 함. 

- 도커 허브
- 이미지 = 저장소
- create repository로 저장소 생성. 깃과 비슷한데?
    - 반대로 깃 레포를 이미지라 생각해보면 레포라는 저장소 개념이 좀 더 와닿는 것 같기도 하고
    - 깃 레포는 이미 하나의 빌드된 이미지인 셈. 코드 뭉치의 특정 시점 스냅샷
    - 그럼 도커 저장소도 버전 관리가 되는걸까?
- 저장소 생성하면 태그 네임 제외한 docker commands 복사해서 실행하면 됨
    - 이 이미지는 로컬에 없는 이미지. 로컬에 없는걸 어떻게 알까?

- `docker push {image name}`
    - 푸쉬할 때 내 계정에 아무나 푸쉬하지 못함
    - 로컬 도커 명령에선 내가 내 계정에 푸쉬하려 해도 모름
    - 이걸 알게 해주는게 `docker login`으로 도커 id와 비밀번호 입력
        - 깃헙에서 config 로 아이디, 이메일 입력하는 것과 유사하네
- `docker pull {imgae name}`
    - 로그인 안해도 풀시켜서 `{계정 id/이미지 태그(이름?)}` 하면 풀 가능
    - latest 이미지를 자동으로 가져옴


## 정리

- 요약하는 장이라 새로운 것 없고, 다만 레이어 개념은 빌드 속도를 최적화시키기 위해 필요하다는 부분
    - 레이어 기반 아키텍쳐가 다른 곳에서도 쓰이는 것 같던데, 그 때도 뭔가를 효율적으로 빌드하기 위함일까?
    - 레이어라는 개념 자체는 누구 머리에서 나온걸까
