# Docker 이미지 & 컨테이너: 코어 빌딩 블록

## 모듈 소개

## 이미지 & 컨테이너: 무엇이며, 왜 사용하는가?
1. 컨테이너
    1. 애플리케이션, 실행 환경등 모든걸 포함하는 패키지 = 소프트웨어 유닛 
    2. 이미지의 구체적인 실행 인스턴스 
2. 이미지
    1. 컨테이너의 블루프린트 / 템플릿 
    2. 실제 코드와 코드 실행이 필요한 도구를 포함 
    3. 이미지를 통해 여러 컨테이너를 생성할 수 있음 
    4. 설정 명령과 코드가 포함한 공유 가능한 패키지

## 외부(사전 빌드된) 이미지의 사용 & 실행
이미지를 가져오는 법

1. 이미 존재하는 것을 가져옴 (공식 이미지, 외부에서 생성한 이미지)
2. 새롭게 생성

컨테이너 실행 

1. docker run node 
    1. Docker hub의 노드 이미지를 기반으로 컨테이너 생성 
2. docker run -i node
    1. 도커에게 컨테이너 내부에서 호스팅 머신으로 대화형 세션을 노출하고 싶다고 알리는 것 

컨테이너와 로컬은 격리되어 있음
(강의에선 로컬에 설치한 node와 컨테이너의 노드 버전을 통해 비교해줌)

이미지로 여러개의 컨테이너 생성 가능
## 우리의 목표: NodeJS 앱

## Dockerfile을 사용하여 자체 이미지 빌드하기
`FROM`

- 다른 베이스 이미지에 새로운 이미지 구축 가능
- 도커 이미지를 처음부터 빌드 가능하지만 코드에 필요한 기타 도구와 같은 OS 레이어가 필요
- 로컬에 설치되어 있는 경우 캐시되어 있음으로 이 이미지를 기반으로 컨테이너를 실행한 순간 로컬 머신에도 존재함

`COPY {호스트 파일 시스템} : {컨터이너/이미지 파일 시스템}`

- 로컬의 파일을 도커로
- 모든 컨테이너에는 로컬 머신의 파일 시스템에서 완전히 분리된 자체 내부 파일 시스템이 있음

`RUN`

- 디폴트로 도커 컨테이너 및 이미지의 작업 디렉토리(컨테이너 파일 시스템의 루트 폴더)에서 실행
- RUN node server.js
    - Dockerfile에 두게 되면 이미지가 빌드될 때마다 실행됨
    - 위의 명령어들은 이미지 설정을 위한 도커에 대한 명령
    - 이미지는 컨테이너의 템플릿
        - 이미지를 실행하는 것이 아니라, 이미지를 기반으로 컨테이너를 실행하는 것
        - 모든 종속성 + 코드를 포함하여 컨테이너를 시작하는 경우에만 서버 시작을 원함

`WORKDIR {실행 디렉토리}`

- 도커 컨테이너의 작업 디렉토리를 설정
- 도커에게 모든 후속 명령이 폴더 내부에서 실행될 것임을 알림

`CMD [명령어 배열]`

- RUN node server.js
    - Dockerfile에 두게 되면 이미지가 빌드될 때마다 실행됨
    - 위의 명령어들은 이미지 설정을 위한 도커에 대한 명령
    - 이미지는 컨테이너의 템플릿
        - 이미지를 실행하는 것이 아니라, 이미지를 기반으로 컨테이너를 실행하는 것
        - 모든 종속성 + 코드를 포함하여 컨테이너를 시작하는 경우에만 서버 시작을 원함
- 이미지가 생성될 때 실행되지 않고 이를 기반으로 컨테이너가 시작될 때 실행됨
    
    

EXPOSE {로컬에 노출할 PORT}

- Dockerfile 최종 명령어 직전에 선언
- 로컬 시스템에 특정 포트를 노출하고 싶다는 것을 도커에게 알림
## 자체 이미지를 기반으로 컨테이너 실행하기
`docker build {도커파일 경로}`

- 이미지 생성

`docker stop {컨테이너 이름}`

- 컨테이너 종료

`EXPOSE {포트}`

- 실제 어떠한 역할은 하지 않고 도큐먼테이션 목적임

`docker run -p {애플리케이션에 액세스 하려는 로컬 포트}:{내부 도커 컨테이너 노출 포트} {컨테이너 이름}`

- publish
    - 도커에게 어떤 로컬 포트가 있는지 알려줌
    - 로컬 머신의 어떤 포트가 내부 도커 특정 포트에 액세스 할 수 있는지
## EXPOSE & 약간의 유틸리티 기능
**ID**를 사용할 수 있는 모든 **docker 명령**의 경우, **항상 전체 ID를 복사**/기록할 필요는 **없고**

첫 번째(몇 개) 문자를 사용할 수도 있으며 고유 식별자를 갖는 것만으로도 충분
``

`docker run abcdefg 
docker run abc`

`docker run a` ("a"로 시작하는 다른 이미지 ID가 없으면)

모두 실행 가능

## 이미지는 읽기 전용!
코드를 변경한다면?

- run을 통해 컨테이너 실행시 변경사항 반영되지 않음
- COPY 를 통해 파일 복사 → 기본적으로 복사한 시점에서 소스 코드의 스냅샷 만듬
- 업데이트된 소스 코드를 새 이미지로 복사시 이미지를 다시 빌드해야 함
    - 이후 코드 변경사항을 선택하는 방법을 배움

⇒ 이미지는 기본적으로 잠겨있고 빌드 되면 끝!
## 이미지 레이어 이해하기
# 

`레이어 기반 아키텍쳐`

- 이미지를 빌드시 변경된 부분의 명령과 그 이후의 모든 명령이 재평가 됨
- 코드 / Dockerfile 변경 없이 이미지 빌드시 캐시 사용함을 볼 수 있음
- 모든 명령은 Dockerfile의 레이어를 나타냄
- 이미지(Read-only) < 컨테이너(Write-only)
- 하나의 레이어가 변경될 때마다 레이어 변경 이후 다른 모든 레이어가 다시 빌드됨
    - 이점을 활용하여 성능을 향상할 수 있는데, 소스 코드를 복사 전에 npm install 레이어가 오게 하기 위해 아래와 같이 코드 수정
    
    ```docker
    COPY package.json /app
    RUN npm install
    COPY . /app
    ```
    
## 첫 번째 요약
이미지에 기반한 여러 컨테이너 생성이 가능하다 

- 이미지는 코드를 포함함
- 컨테이너는 이미지에 얇은 레이어를 추가한 이미지 기반의 어플리케이션
- 일단 실행되면 실행 중인 다른 컨테이너와는 독립적인 스탠드얼론
- 컨테이너가 이미지에서 코드와 환경을 새 컨테이너나 새 파일로 복사하지 않음
    - 컨테이너는 이미지에 저장된 환경을 사용 + 부가 레이어를 추가
## Images & Containers

## 이미지 & 컨테이너 관리

## 컨테이너 중지 & 재시작
`—help`

- 도커의 모든 명령어에 사용 가능

`docker ps -a`

- 중지한 컨테이너를 포함한 모든 컨테이너 표시

`docker run`

- 매번 이 명령어를 통해 실행할 필요 없음
- 이미지를 기반으로 새 컨테이너를 만들고 그 이후에 새 컨테이너가 시작

`docker start {컨테이너 이름 / 아이디}`

- 컨테이너가 백업
## Attached & Detached컨테이너 이해하기
`docker start {컨테이너 이름}`

- 터미널의 프로세스가 즉시 완료, 컨테이너는 백그라운드로 실행 중
    - detached 모드가 default
    - `-a` 를 통해 attached 모드로 변경
    - cf) `docker run {컨테이너 이름}` 는 attached 모드
        - 변경하려면 `-d` 옵션을 추가하여 detached 모드로 변경

`docker attach {컨테이너 이름}`

- 도커에 접속

`docker logs {컨테이너 이름}`

- 출력된 과거의 로그
- `-f` 를 통해 수신 대기

`docker attach CONTAINER`

- 디폴트로 '`-d`' 없이 컨테이너를 실행하면, "attached모드"로 실행됩니다.
- detached 모드(예: `-d`)로 컨테이너를 시작한 경우에는 `attach` 명령을 사용하여 컨테이너를 다시 시작하지 않고도 컨테이너에 연결할 수 있습니다.
- 이는 `CONTAINER`라는 ID 또는 이름으로 실행 중인 컨테이너에 연결합니다.
## 이미 실행 중인 컨테이너에 연결하기

## 인터렉티브 모드로 들어가기
`docker run -i -t {컨테이너 이름}`

- `-i` : interactive
- `-t` : terminal
- `-it` : 둘의 결합
- 위의 옵션은 `—help` 로 확인
- `docker start -a` 도 동일하게 동작하는 듯 하지만 한 번의 실행만 가능함으로 `-i` 를 함께 사용
## 이미지 & 컨테이너 삭제하기
`docker rm`

- 컨테이너를 제거
- 제거 전 컨테이너의 실행을 중지해야 함
- 한 번에 여러 개의 컨테이너 이름을 넣어 docker rm을 파상함으로써 여러개 삭제 가능

`docker rmi {이미지 아이디}`

- 이미지와 내부의 모든 레이어 삭제
- 컨테이너에서 사용되지 않고 중지된 컨테이너가 포함되지 않은 경우에만 가능
- 컨테이너가 시작, 중지 되더라고 제거 불가능 하니 컨테이너 선삭제 필요
- 한 번에 여러 개의 이미지 삭제 가능
- 전체 삭제는 `docker image prune`
## 중지된 컨테이너 자동 제거하기
`docker run —rm {이미지 아이디}` 

- 중지된 컨테이너 제거
## 작동 배경 살펴보기: 이미지 검사
컨테이너는 이미지 기반 빌드, 여러 컨테이너는 이미지 내부의 코드를 공유

→ 이미지 내부의 코드는 잠겨있고 읽기 전용 컨테이너만 변경 가능

→ 이미지 레이어 위에 추가된 새로운 얇은 부가 컨테이너 레이어 내부에 파일을 만듬 

`docker image inspect {이미지 ID}`

- 생성 시간, OS 환경, 레이어 등 확인 가능
## 컨테이너에/컨테이너로 부터 파일 복사하기
`docker cp {소스} {컨테이너이름:/목적지}`

- 예 : docker cp {dummp(폴더명) 혹은 dummp/.(파일 전체)} boring:/test
- 반대로도 가능
- 변경된 코드를 cp 하고 싶은 경우
    - 예 : 웹서버의 설정 파일
## 컨테이너와 이미지에 이름 지정 & 태그 지정하기
`docker run -name`

- 컨테이너에 이름 지정

`docker build  -t name:tag`

- 이미지에 태그 지정
- name : tag
    - name : 여러개의 특정화된 이미지 그룹 지정
    - tag : 이미지의 보다 특정화된 버전
    - 이미지의 특정화된 버전에 대한 고유 식별자를 언제나 가지게 됨
## 이미지 공유하기 – 개요
도커와 컨테이너를 사용할 때의 이점

- 로컬 종속성을 uninstall 하고 재설치 할 필요가 없는것
- 다른 사람/컨테이너를 배포하고자 하는 서버에 이미지를 공유 가능
    1. 도커 파일과 애플리케이션에 속한 소스 파일 공유함으로써 이미지 빌드 및 컨테이너 실행 가능
    2. 빌드된 이미지 전체를 공유 
        1. 추가 코드, 폴더, 빌드 과정 필요 없이 모두 포함
## DockerHub에 이미지 푸시(push)하기
`docker push IMAGE_NAME`

- 도커 허브 / 다른 공급자에게 이미지 공유 가능
- ↔ `docker PULL IMAGE_NAME`
    - 로그인 없이도 가능
    - pull 받은 `IMAGE_NAME` 전체로 run 해야 함
    - 컨테이너 레지스트리에서 최신 이미지를 가져옴
    - docker pull을 먼저 실행하지 않고 `docker run` 실행하는 경우
        - 로컬 컴퓨터에서 이미지를 찾지 못하면 이미지 이름이 사용한 컨테이너 히스토리에 자동으로 접근 이미지를 확인하여 이를 통해 자동으로 풀링
        - 로컬에 있으면 자동으로 받아오지 않음
- 도커 허브의 경우 `IMAGE_NAME`에 `DOCKER ID:` 추가해주어야 함
    - 이때 docker tag 명령어를 통해 `DOCKER ID:IMAGE_NAME` 로 태그를 수정해주자
- access 되지 않을 경우 권한 확인 후  `docker login`
- push 하는 경우 `docker image` 를 통해 확인한 용량 전체를 올리는 것이 아닌 공식 이미지를 제거한 용량이 올라감으로써 도커 허브는 용량을 줄이고 올리는 사람은 대역폭을 절약 할 수 있음
## 공유 이미지 가져오기(pull) & 사용하기

## Managing Images & Containers

## 모듈 요약

## 모듈 리소스
