# 정리 및 새롭게 알게된 점

## 데이터 카테고리
1. 이미지는 읽기 전용 데이터
2. 임시 애플리케이션 데이터 : 애플리케이션이 실행되는 동안 생성된 데이터(없어져도 되는 임시데이터)

```
도커 : read-write액세스 권한을 가지며 파일시스템 조작
- 컨테이너에 저장된다는 것은 이미지 위에 도커에 의해 추가된 것
- 컨테이너 레이어는 실제로 컨테이너를 구성
- 이미지를 인식하고, 복사하지 않고 파일시스템을 미러링하는 로직
- 이미지에서 변경하지 않고 부가레이어에서 변경
- 도커는 컨테이너의 변경사항을 추적하고, 이미지의 파일 시스템을 가져와 최종 파일 시스템을 파생시켜 read-write 레이어에 저장된 변경 사항과 결합
- 배후에서 일어나는 일로 우리에게 그다지 중요하지 않음
- 컨테이너에 저장하라고하면 컨테이너는 정보를 저장, 파일이 무엇이든 read-write레이어에 저장하거나, 그 레이어의 도움을 받아 저장
- 모두 로컬환경이나 이미지가 아닌 아닌 컨테이너에 있음
```
3. 영구 애플리케이션 데이터 : 사용자가 등록하면 자신을 잠금. 사용자 정보를 받아 파일에 저장하거나 데이터베이스에 저장. 실행중인 컨테이너에서 그 데이터를 가져와 생성. 컨테이너가 중지되었다 다시 시작해도 데이터는 그대로 있음 -> 컨테이너에 저장하지만 볼륨의 도움을 받음

## 데모 앱 구축 & 이해하기 / 문제
- 컨테이너/이미지와 로컬파일 시스템 간에는 열결 되지 않음 (copy로 폴더복사 일회성 스냅샷, 파일 생성 시 컨테이너 내부에만 있음)
- 파일 시스템이 컨테이너 내부에 있어 컨테이너를 stop하면 파일은 그대로 삭제(rm)하면 파일 삭제
- 컨테이너를 삭제하면 읽기전용인 이미지만 남아 파일을 찾을 수 없음

## 볼륨
- 컨테이너 내부의 폴터를 외부 폴더에 연결 = 동기화 -> 볼륨
- 컨테이너가 제거되어도 볼륨이 유지됨 -> 데이터 유지
- 볼륨에 데이터를 읽거나 쓸 수 있음

## 2가지 타입의 도커 외부 데이터 저장소
### 볼륨
- 익명볼륨(VOLUME [ "/app/feedback" ])
    - 실패, 컨테이너 내부경로만 설정함 -> 도커가 임의로 부여
    - 익명이기 때문에 컨테이너가 존재하는 동안에만 존재
    - 폴더가 로컬머신에 계속 존재할 수 있다면 괜찮 -> 명명된 볼룸 
    - '--rm' 옵션으로만 익명볼륨 자동제거(docker rm .. 으로는 제거X), but 컨테이너를 다시 시작하면 새 익명볼륨 생성 -> 'docker volume rm VOL_NAME' 또는 'docker volume prune'으로 삭제
    - -v /app/node_modules 
- 명명된 볼륨
    - dockerfile 안에 생성할 수 없음
    - 컨테이너 build 할때 '-v feedback:/app/feedback' 추가
- 볼륨은 파일의 영구 저장은 되지만 호스트 머신 어디에 저장 되있는지 몰라 코드 수정은 불가

### 바인드 마운트 
- 도커에 의해 관리되는 볼륨의 위치를 모름 -> 바인드 마운트는 호스트 머신 상에 매핑될 컨테이너의 경로를 설정
- 컨테이너는 볼륨에 쓸 수 있고, 쓸 수 있음 -> 소스코드를 바인드 마운트에 넣을 수 있음
- 소스코드를 실제로 스냅샷에서 복사하는것이 아닌 바인딩 마운트에 복사 -> 그 폴더는 호스트 머신의 어떤 폴더에 연결, 컨테이너는 항상 최신 코드에 액세스
- 코드가 있는 폴더의 결대 경로를 볼륨으로 추가해줘야됨, 전체 볼륨 매핑경로를 큰따옴표로 묶기
    - -v "/Users/docker-compete:/app"
    - mac/Linux : -v $(pwd):/app, Windows : -v "%cd%":/app
- 도커가 엑세스 할 수 있는지 확인 필요
    - Docker Desktop -> preferences -> Resources-File Sharing -> 공유하고 있는 폴더가 리스팅 되있는 지 확인

익명볼륨으로 해결 -v /app/node_modules -> 익명볼륨을 추가하여 해결(53강, 56강 다시보기)

## NodeJs : Nodemon
- nodemon을 사용하여 파일이 변경될 때마다 자동으로 서버 재실행

## 읽기전용 볼륨

## Docker 볼륨 관리
```
docker vloume ls # docker 볼룸 목록

#바인드 마운트는 도커에 의해 관리되는 볼륨이 아니기 때문에 리스트에 없음

docker volume create feedback-files  # 볼륨 생성
docker volume prune  # 사용하지 않은 볼륨 삭제
docker volume rm feedback  # 볼륨 개별 삭제
docker volume inspect feedback # 볼륨정보
```

## COPY vs 바인드마운트
- 둘중에 하나 사용가능
- copy는 스냅샷, 프로덕션 환경에서
- 바인드 마운트는 실시간 반영되기 때문에 개발 환경에서만

## dockerignore
- .dockerignore

## 환경변수 & env
- 빌드타임 인수
    - dockerfile에서 특정 dockerfile 명령으로 다른 값을 추출하는데 사용할 수 있는 변수 설정할 수 있음
    - build할 때 '--build-arg' 옵션과 함께 제공되는 인수를 기반
- 런타임 환경변수
    - dockerfile 내부에서 사용
- 인수는 실행중인 애플리케이션의 전체 코드에서 사용, Dockerfile 내부의 'ENV' 옵션으로 설정하여 해당 환경변수가 존재한다고 Docker에 알린다음, docker run에서 --env 옵션 구체적인 값을 제공
- 인수와 환경변수를 이용하여 유연한 이미지와 컨테이너 만들 수 있음


# 함께 이야기하고 싶은 점, 느낀점
- 도커의 구조와 레이어에 대해 이해할 수 있는시간이었다
- 그동안 명명된볼륨을 잘 사용하고 있었는데 익명볼륨과 바인드마운트의 개념에 대해서는 처음알게되었다. 익명볼륨의 경우 아무래도 사용해보고 설명을 들으니 더 잘 와닿고 이해가 잘되는것 같다.(익명 볼륨과 바인드마운트는 아직 실용적인 용도를 잘 모르겠다)