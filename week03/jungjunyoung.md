## 챕터 요약

![container_width_volume_001](https://s3.ap-northeast-2.amazonaws.com/blog.resource/images/container_with_volume_001.jpeg)





<br />

## 데이터 카테고리 / 다양한 종류의 데이터 이해하기



### 소스코드와 환경

애플리케이션 코드와 환경은 읽기 전용이어야 한다.

실행 중인 애플리케이션은 소스 코드 편집을 해서는 안된다.

<br />



### 임시 앱 데이터

애플리케이션이 실행되는동안 생성된 임시 데이터는 어떨까?

* 유저의 인풋 데이터
* 실행중인 컨테이너에서 fetch / produce 된 데이터
* 메모리나 임시 파일에 저장된 데이터

이러한 임시 데이터들은 readOnly인 이미지에 저장할 수 없기 때문에, 이미지가 아닌 컨테이너에 저장된다. 

컨테이너에 저장된 임시 데이터는 컨테이너가 중지될 때가 아닌, 삭제될 때 사라진다는 것에 주의하자.



<br />

### 영구 앱 데이터

컨테이너가 종료되더라도 영구적으로 저장되어야 하는 데이터도 있다.

* 유저의 계정 정보
* 실행중인 컨테이너에서 fetch / produce 된 데이터
* 파일이나 데이터베이스에 저장된 데이터

이러한 영구 데이터들 역시 readOnly 인 이미지에 저장할 수 없으므로, 이미지가 아닌 컨테이너에 저장된다. 그러나 영구 데이터는 컨테이너가 삭제되더라도 유지되어야 하므로, 볼륨이라는 것의 도움을 받는다.



<br />



## 볼륨

도커에 내장된 기능으로, 데이터를 유지하는 데에 쓰인다.

볼륨은 호스트 머신의 폴더 경로를 컨테이너의 내부 폴더에 매핑하는 방식으로 동작한다.

볼륨은 컨테이너가 제거되더라도 유지되므로,  데이터 역시 지워지지 않는다.

컨테이너는 볼륨의 데이터를 읽고, 쓸 수 있다.

<br />



## 컨테이너에 익명 볼륨 추가하기 

```dockerfile
FROM node:14

WORKDIR /app

COPY package.json .

RUN npm install

COPY . /app

EXPOSE 80

# VOLUME 키워드를 사용, 컨테이너 내부와 호스트 머신의 '어떤' 폴더 경로를 매핑한다.
# ["컨테이너 내부 폴더 경로"]
# 아래 예시는 컨테이너 내부의 app/feedback 폴더를 호스트 머신의 '어떤' 폴더 경로에 저장하겠다는 의미.
VOLUME ["/app/feedback"]

CMD ["node", "server.js"]
```

호스트 머신의 '어떤' 폴더라고 표현한 이유는, 개발자는 이 '어떤' 폴더의 위치를 알 수 없으며, 액세스해서도 안되기 때문이다.

이러한 볼륨의 사용 형태를 익명 볼륨이라고 하는데, 익명 볼륨은 컨테이너가 제거될 때 함께 제거되고, 이후 복구되지 않는다. 

그렇다면 굳이 익명 볼륨을 써야 할 이유가 있을까?





<br />

## 익명 볼륨과 명명된 볼륨

볼륨에는 익명 볼륨과 명명된 볼륨이 있다.

앞서 봤듯, 익명 볼륨은 컨테이너가 제거될 때 함께 제거되고, 복구되지 않으므로 그다지 유용하지 않다.

그러나 명명된 볼륨은 컨테이너가 제거되더라도 남아있으며, 해당 볼륨을 사용하고자 하는 새로운 컨테이너가 생성되면 볼륨이 복구된다.

명명된 볼륨 역시 익명 볼륨과 마찬가지로 개발자가 위치를 알 수 없으며, 직접 액세스하거나, 수정할 수 없다.

익명 볼륨은 아래에서 살펴볼 바인딩 마운트를 사용할 때, 외부 경로보다 컨테이너 내부 경로의 우선 순위를 높이는 데 사용할 수 있다.



<br />

## 컨테이너에 명명된 볼륨 연결하기 

명명된 볼륨은 Dockerfile 에 구문을 추가하여 생성하지 않고, 컨테이너를 실행할 때 생성할 수 있다.

`docker run --rm -d --name test-container -p 3000:80 -v feedback:/app/feedback test:latest `

위 명령에서 `-v feedback:/app/feedback `  에만 집중하자.

해당 명령은 `feedback` 이라는 이름의 볼륨에, 컨테이너의 `/app/feedback` 디렉토리를 매핑하겠다는 의미이다.

구조는 `-v 볼륨이름:컨테이너 내부 폴더 경로` 가 되겠다.

명명된 볼륨을 생성하면, 해당 볼륨을 사용하는 컨테이너가 제거되더라도 볼륨이 남아있게 된다.

따라서 컨테이너를 새로 생성하여 해당 볼륨을 사용하려면, 위의 명령어 (`docker run ...` 를 그대로 사용하면 된다.



명명된 볼륨은 `docker volume create 볼륨이름`  명령어로 생성할수도 있다.



<br />



## 볼륨과 바인딩 마운트

볼륨은 컨테이너가 실행될 때 연결된다.

볼륨은 볼륨이 위치한 정확한 경로를 알 수 없으며 도커 없이 직접 액세스할 수도 없다.

그러나 바인딩 마운트는 다르다.

바인딩 마운트는 개발 도중 소스 코드의 변동이 있을 떄마다 이미지를 리빌드해야 하는 불편함을 해결하기 위해 등장했다.

바인딩 마운트는 개발자에게 컨테이너 내부와 매핑될 호스트 머신 상의 경로를 오픈한다. 즉, 개발자는 컨테이너와 매핑될 호스팅 머신의 데이터 저장 공간의 위치를 알 수 있다.

이를 응용하여, 컨테이너가 바인딩 마운트 상의 코드를 읽게 함으로써 호스팅 머신의 코드 변경 사항이 컨테이너에 실시간으로 반영되도록 할 수 있다.

바인딩 마운트는 위의 `-v`  옵션의 콜론에 볼륨 이름이 아닌 로컬 머신 경로를 입력하면 된다.

`docker run --rm -d --name test-container -p 3000:80 -v $(pwd):/app test:latest`

로컬 머신 경로를 읽는 명령어는 OS 에 따라 다르다.

macOS / linux : `-v $(pwd):/app`

Window: `%cd%:/app`



## 바인딩 마운트에 대한 개인적인 생각

개인적으로는 바인딩 마운트의 (로컬 호스팅 머신 <-> 컨테이너 내부) 소통 방식이 이미지-컨테이너의 일관성을 깬다고 생각하므로, 사용을 지양해야 한다고 생각한다.

바인딩 마운트로 호스트에서 컨테이너 내부의 파일이나 코드를 수정할 수 있다고 하면, 컨테이너가 자신의 블루프린트인 이미지에서 의도한 것과는 다른 내용물을 갖게 될 수도 있다는 의미인데, 그럼 이미지-컨테이너 간의 신뢰가 깨지지 않을까?  

한편으론 결국 공유하는 것은 이미지이기 때문에, 개발이 끝나면 수정된 코드를 가지고 이미지를 다시 빌드하면 문제 없어 보이기도 한다.

개발 중에 이미지를 리빌드하는 것이 왜 불편한지, 이 부분을 근본적으로 해결해야 할 것 같다. 바인딩 마운트는 꼼수(?) 같이 느껴진다.

이 부분은 도커를 좀 더 사용해보고 나서 파헤쳐봐야겠다.



<br />



## .dockerignore 를 통한 COPY 무시

현재의 Dockerfile은 다음과 같다.

```dockerfile
FROM node:14

WORKDIR /app

COPY package.json .

RUN npm install

COPY . /app

EXPOSE 80

CMD ["node", "server.js"]
```

COPY 명령을 보면, 호스팅 머신의 모든 폴더와 파일을 컨테이너의 /app 폴더에 복사하고 있음을 알 수 있다.

그런데 만약 호스팅 머신의 일부 파일들은 컨테이너에 복사되지 않기를 원한다면 어떨까? 

예를 들면, node_modules 같은 폴더는 앞의 `RUN npm install` 명령어에 의해 컨테이너의 /app 폴더에 자동으로 생성될 것이므로, 굳이 로컬 호스팅 머신의 `node_modules` 를 복붙할 필요가 없다.

이외에도 `Dockerfile`,   `.git` 폴더 등이 ignore 목록에 추가될 수 있겠다.



<br />

## 빌드 타임 인수 (ARGuments) , 환경변수 (ENVironment variables)

도커는 빌드 타임 인수와 런타임 환경 변수를 지원한다.

빌드타임인수는 도커 이미지가 빌드될 때 사용할 인수이므로,  Dockerfile의 CMD 명령이나 애플리케이션 코드에서 접근할 수 없다.

환경변수는 도커 컨테이너가 실행될 때 사용하는 변수이므로, Dockerfile이나 애플리케이션 코드에서 접근할 수 있다.



<br />

## 환경변수 설정



### Dockerfile 을 통한 환경변수 설정

환경변수는 기본적으로 Dockerfile 에 선언해놓고 사용할 수 있다.

```dockerfile
FROM node:14

WORKDIR /app

COPY package.json .

RUN npm install

COPY . /app

# 아래 환경변수는 애플리케이션 코드 내부에서 process.env.PORT 로 접근할 수 있다.
# ENV 환경변수이름 환경변수값
ENV PORT 80

# Dockerfile 내부에서도 환경변수를 사용할 수 있다.
EXPOSE $PORT

CMD ["node", "server.js"]
```

이러한 방식은 이미지를 빌드할 때 환경 변수를 선언하므로, 컨테이너를 실행할 때 별도의 환경변수를 주입시켜주지 않아도 된다는 편리함이 있다.

그러나, 이미지에 환경 변수가 포함된다는 것은 이미지를 가진 모든 이가 `docker history 이미지명` 명령어로 환경 변수를 읽을 수 있다는 것을 의미한다. 

만약 보안적으로 중요한 값인 자격증명, 개인 키 등이 이미지에 포함되어 있다면 이는 엄청난 문제가 될 것이다.

따라서 보안 이슈가 있는 중요한 환경변수는 웬만하면 Dockerfile에 상수로 선언해두지 말자. 





<br />

### docker run 명령어에서 환경변수 설정

위 Dockerfile 에 명시된 `ENV` 명령을 통한 환경변수 설정은 이미지를 빌드할 때 실행된다. 이는 런타임에서 덮어쓸 수 있다.

```shell
docker run --rm -d -p 3000:8000 -e PORT=8000 --name test-container test
```

`-e PORT=8000`  명령어에 주목하자. -e 옵션을 통해 PORT 라는 환경변수의 값은 8000이라고 명시했다. 이제 애플리케이션 내부에서 `process.env.PORT` 로 PORT 라는 환경변수에 접근하는 변수는 모두 8000이라는 값이 적용된다.



<br />

### .env 파일을 통한 환경변수 설정

환경 변수를 설정하는 파일인 `.env`  파일을 통해 환경변수를 설정할수도 있다.

```shell
docker run --rm -d -p 3000:8000 --env-file ./.env --name test-container test
```

`--env-file ./.env` 명령어에 주목하자. 해당 명령어는 환경변수가 위치한 파일을 이용하여 환경 변수를 설정한다.



<br />

## 빌드 타임 인수 (ARGument) 사용하기

이미지를 빌드할때 사용할 수 있는 인수를 사용해보자.

기본은 Dockerfile 에 명시하는 것이다.

```dockerfile
FROM node:14

WORKDIR /app

COPY package.json .

RUN npm install

COPY . /app

# DEFAULT_PORT 라는 키에 80 이라는 값을 넣는다.
# 빌드 타임 인수는 이미지 빌드 타임에 실행되는 명령이라면 Dockerfile 내에서 어디든 사용할 수 있다.
ARG DEFAULT_PORT=80

# 환경변수 설정 명령인 ENV는 이미지 빌드 타임에 실행되는 명령이므로 위의 빌드 타임 인수인 DEFAULT_PORT 를 사용할 수 있다.
ENV PORT $DEFAULT_PORT

EXPOSE $PORT

CMD ["node", "server.js"]
```

이외에도 도커 이미지를 빌드할 때 인수를 넣어줄 수도 있다.

```shell
docker build -t test:arg --build-arg DEFAULT_PORT=8000 .
```

`--build-arg DEFAULT_PORT=8000` 명령어만 보면 된다.



