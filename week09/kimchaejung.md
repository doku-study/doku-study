# Docker & 컨테이너 - 요약

## 컨테이너의 핵심 개념

- isolated: 컨테이너는 코드와 그 코드를 실행하는데 필요한 환경을 포함하는 격리된 박스
- single-task-focused: 컨테이너는 하나의 일만 하도록 구성한다
- shareable, reproducible: 공유 및 재생산이 쉬운 작고 가벼운 패키지를 갖는 것

→ 컨테이너에 고정된 재현 가능한 환경을 갖게 되는 것

- stateless: 볼륨을 제외하고 컨테이너를 종료하면 데이터가 손실된다

## 이미지의 핵심 개념

- Dockerfile로 만들거나 Docker Hub에서 가져온다
- 이런 이미지 위에 컨테이너가 부가 레이어로 얹어진다
- shareable
- blueprint: 이미지 기반 다중 컨테이너 생성 가능
- read-only: 실행되는 것이 아니다, 직접 쓸 수 없고 절대 변경되지 않음

## 주요 명령

```bash
# Dockerfile 기반으로 이미지 빌드
docker build -t IMAGE_NAME:TAGE .

# remote 혹은 local 이미지 기반 컨테이너 실행
docker run --name CONTAINER_NAME --rm -d IMAGE_NAME

# Registry에 이미지 공유
docker push REPOSITORY/NAME:TAG
# Registry로 부터 이미지 fetch
docker pull REPOSITORY/NAME:TAG
```

## Data

- 컨테이너는 격리되고 stateless이다.
  - 컨테이너가 가진 데이터와 파일시스템은 호스트 머신과 분리되어 저장되지만 컨테이너 종료에 따라 데이터가 손실된다
- Bind Mount: 호스트 머신에 특정 경로가 있고, 그 경로와 컨테이너에 미러링하는 경로를 알고 있다
  - 실행 중인 컨테이너에서 적용해야 하는 소스 코드 또는 설정이 있는 경우 쓰인다
- Volume: 컨테이너 폴더가 로컬 시스템의 폴더로 미러링되지만 그 경로를 사용자가 알 수 없다

## Network

- 컨테이너는 격리되어 있지만 http와 같이 요청을 보내는 것은 가능하다
- 컨테이너 IP를 지정한다
  - 변경 가능성이 있어 수동 지정을 해야함
- network를 생성하고 각각의 컨테이너에 추가
  - 각 컨테이너의 이름을 요청 주소로 쓸 수 있다

## Docker-compose

- 도커를 사용하면 컨테이너를 실행하고 이미지를 빌드할 수 있지만 환경 변수, 볼륨, 네트워크 설정이 있는 경우 명령이 길어진다 + 다중 컨테이너 환경
- 컨테이너 시작 구성을 yaml 파일에 넣을 수 있고, 그 구성 파일에 정의된 컨테이너를 초기화하고 시작한다

```bash
# 빌드되지 않은 이미지 빌드 + 모든 컨테이너 실행
docker-compose up
# 시작된 모든 컨테이너 중지
docker-compose down
```

## Local vs Remote

- Local

  - 개발과 재현 가능하고 격리된 개발 환경을 위함
  - Docker는 격리, 캡슐, 재현 가능한 개발 환경을 제공
  - 관리하기 쉬워 시스템의 다른 환경과 충돌하지 않음

- Remote
  - Docker로 애플리케이션을 배포하기 위함
  - Docker는 격리, 캡슐, 재현 가능한 개발 환경을 제공
  - 용이한 업데이트: 기존의 컨테이너를 업데이트된 컨테이너로 교체한다

## 직접 통제 vs 관리형 서비스

- 직접 통제
  - 사용자 컨테이너에서 remote server 설치, Docker 설치
  - 전체 통제 권한을 가지고 있기 때문에 설정 자유도가 높지만 그만큼 전부 관리를 해야한다
- 관리형 서비스
  - 통제 범위가 줄어들어 사용하기 쉽고, 책임이 줄어든다

# Kubernetes 시작하기

> 쿠버네티스란 컨테이너 오케스트레이션과 대규모 배포에 도움이 되는 도구이자 표준 모음이자 프레임워크
> [Production-Grade Container Orchestration](https://kubernetes.io/)

## 앞으로 배울 것

- 컨테이너를 배포할 때 직면할 수 있는 문제
- 쿠버네티스가 이를 어떻게 해결할 수 있는지
- 핵심 쿠버네티스 개념, 구성 요소 탐색
- 컨테이너를 실제 클라우드 프로바이더의 프로덕션 환경에 배치하는 방법

## 수동 배포의 더 많은 문제점들

- 보안 구성뿐만 아니라 자체적으로 관리, 구성하는 수동 배포는 유지하는 것이 힘들다, error-prone
- 컨테이너가 충돌하거나 다운되는 경우 수동으로 새 컨테이너로 교체해야 한다
  - → container health checks + 자동 재배포
- 트래픽 급증 시 더 많은 인스턴스들이 필요하다
  - 실행 중인 인스턴스를 경우에 따라 증감을 해야한다
  - → autoscaling
- 트래픽이 인스턴스에 균등하게 분배되어야 한다

  - → load balancer

- ECS가 수동 배포의 문제점을 해결할 수 있다

- 하지만 클라우드 서비스에 갇히게 된다
  - 그 서비스의 특정 조건, 설정 구성 옵션을 따로 학습해야 한다

## Kubernetes가 정확히 무엇인가?

- 오픈 소스 시스템이자 컨테이너 배포를 관리하고 컨테이너를 오케스트레이션하기 위한 사실상의 표준
- 자동 배포, 스케일링, 로드 밸런싱, 모니터링
- 필수 생성, 필수 관리 리소스를 설명하는 표준화된 방법이 존재
- 특정 클라우드 서비스에 추가 구성이 필요한 경우 추가 가능

## 쿠버네티스가 아닌 것, 인 것

- 클라우드 서비스가 아니라 오픈 소스이다
- 클라우드 서비스가 제공하는 것이 아니다
- 특정 클라우드 서비스에 국한되어 있지 않다
  - 어디서나 사용할 수 있다
- 단순히 머신에서 실행하는 소프트웨어가 아니다
  - 개념과 도구 모음
- Docker의 대안이 아니다
  - docker container와 함께 작동하여 컨테이너를 어디서나 배포할 수 있다
- 유료가 아니다!(우왁!)
- 물론 클라우드 서비스를 이용할 때는 비용을 지불한다

> 다중 머신을 위한 Docker-compose와 비슷 === 배포용 Docker-compose

## Kubernetes: 아키텍처 & 핵심 개념

- Worker Node: 컨테이너를 실행하는 머신 내지는 가상 인스턴스
  - Pod: 쿠버네티스 세계의 가장 작은 단위
    - 단순히 컨테이너를 보유한다
    - 컨테이너를 실행할 책임이 있다
    - 쿠버네티스에 의해 사용 가능한 모든 워커 노드로 자동 배포
  - Proxy: 워커 노드에서 네트워크 트래픽 제어
- Master Node: 워커 노드와 상호작용하는 컨트롤 센터, 리모트 머신
  - 워커 노드와 워커노드 상에서 실행 중인 포드과 상호작용하는 책임을 가진다
  - Control Plane: 다양한 서비스의 다양한 도구 모음

> 👩‍💻 쿠버네티스의 개념은 객체 지향인가?

- 클러스터를 형성한다
  - 이 모든 부분이 하나의 네트워크를 생성한다
  - 해당 네트워크로 클라우드 서비스에게 지시한다

## 쿠버네티스를 하기 전 해야하는 것

- 클러스터와 노드 인스턴스 생성
- 노드에 모든 쿠버네티스 소프트웨어 설치
- 특정 클라우드 서비스에서는 추가 설정을 해야할 수도 있다
  - ex) 로드 밸런서, 파일시스템

## 쿠버네티스가 하는 것

- 포드를 생성하고 관리한다
- 사용 가능한 리소스를 활용하기 위해 자동 배포
- 작동 상태를 유지하며 모든 것을 관리

## Worker Node

- 워커 노드를 하나의 컴퓨터 / 머신 / 가상 인스턴스라고 생각하자
  - 우리의 컴퓨터 / 머신이다!(두둥탁
  - 인터넷 어딘가에 특정량의 CPU와 메모리가 있는 머신일 뿐
- 워커 노드는 마스터 노드에 의해 관리된다
- 워커 노드 내부에 포드가 있다
  - 포드: 하나 이상의 애플리케이션 컨테이너와 컨테이너에 속한 모든 리소스(볼륨, IP, 실행 설정)를 호스팅한다
  - 포드는 쿠버네티스에 의해 관리된다(ex. 포드 생성, 포드 삭제)
  - 포드가 삭제되면 포드는 내부적으로 포드에 속한 컨테이너를 실행하고 관리할 수 있다
    > 👩‍💻 ??
  - 포드 내부에 여러 컨테이너를 가질 수도 있다
  - 워커 노드에 둘 이상의 포드가 실행되는 게 일반적이다
- 워커 노드 안에 도커를 설치해야 한다
- 워커 노드 안에 kubelet이 실행되고 있다
  - 마스터 노드와 워커 노드의 통신을 맡는다
- 워커 노드 안에 kube-proxy를 가진다
  - 트래픽 관리

## Master Node

- API Server
  - 워커 노드에서 실행되는 Kubelet에 대한 카운터 포인트(대응자)
- Scheduler
  - 포드 관찰, 새 포드가 생성되어야 하는 워커 노드를 선택하는 것을 담당
  - 워커 노드에 무엇을 해야할 지 API Server에 알리는 역할
- Kube-Controller-Manager
  - 워커 노드 전체 감시 및 제어
  - 포드의 수가 적당한지 확인하는 역할
- Cloud-Controller-Manager
  - 특정 클라우드 서비스에게 무엇을 하는지 알리는 역할

> 👩‍💻 약간 생물학 배우는 느낌… 서로 연관되어 있고 도움주고 각 기관이 어떤 역할을 가지고 있다…
