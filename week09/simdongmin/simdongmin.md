# 새롭게 알게된 점

- 도커 & 컨테이너 정리 
- 쿠버네티스 



## 도커 & 컨테이너 정리 



### 컨테이너 

- 컨테이너는 코드와 그 코드를 실행하는데 필요한 환경을 포함하는 **격리된** 공간 
- 일반적으로 컨테이너는 **하나의 테스크**에 집중함.

- 핵심 아이디어는 **공유 및 재생산**이 쉬운 작고 가벼운 패키지
- 컨테이너는 상태를 가지지 않음. 이전 상태를 기억하지 않음. (볼륨 데이터 제외)

### 이미지

- 이미지는 **컨테이너의 기반**이 되는 스냅샷
  - 컨테이너는 이미지 위의 얇은 부가 레이어
  - 하나의 이미지로 여러 컨테이너를 구동할 수 있음.
- 이미지 자체는 **Read-Only**로 실행되지 않음.
- 이미지는 **여러 레이어**로 구성되며, 레이어를 캐싱하여 빌드 시간을 최적화할 수 있음.
- 이미지는 도커 파일로 생성하거나 Hub에서 가져와 **공유 가능**함.



### 주요 명령 

#### 1. 도커 이미지 빌드 (Dockfile을 기반으로)

`docker build -t NAME:TAG .`

- 도커 이미지의 이름과 버전을 명시하여 구분할 수 있음.
- 빌드할 dockerfile의 위치를 지정

#### 2. 도커 컨테이너 실행

`docker run --name NAME --rm -d IMAGE`

- 도커 이미지(이름과 태그)를 기반으로 컨테이너를 실행
- 컨테이너 이름을 지정할 수 있음. 
- 컨테이너 중지시 자동 제거 옵션과 
- Detach 모드 옵션 사용 가능

#### 3. 도커 이미지를 등록소에 등록 (default: DockerHub)

`docker push REPOSITORY/NAME:TAG`

- 도커 허브의 경우 REPOSITORY는 "계정이름/이미지이름"

#### 4. 도커 이미지를 등록소에서 가져오기 (default: DockerHub)

`docker pull REPOSITORY/NAME:TAG`

- 도커 허브의 경우 REPOSITORY는 "계정이름/이미지이름"



### 데이터, 볼륨, 네트워킹

#### 1. 바인드 마운트

- 컨테이너는 컨테이너 로컬 시스템과 분리된 각자의 데이터와 파일 시스템을 보유하고 있다. 
  - 이를 바인드 마운트로 로컬 시스템과 연결할 수 있다.
  - `-v /local/path:/container/path`
  - 개발중에 주로 사용, 미러링 된다. 소스코드 변경 등 
  - 일종의 개발용 도구로 활용

#### 2. 볼륨

- 컨테이너는 각자 데이터를 가지고 있지만, 컨테이너의 무상태 특성상, 컨테이너가 삭제될 경우 해당 데이터 삭제된다. 
  - 볼륨을 사용하여 데이터의 영속성을 보장할 수 있다. 
  - `-v NAME:/container/path`
  - 명명 볼륨과 익명 볼륨으로 나누어진다.



#### 3. 네트워크

- 컨테이너의 경우 외부 인터넷과 통신할 수 있다. 
- 또한 컨테이너끼리도 통신할 수 있는데 2가지 방법이 있다. 
  1. 컨테이너의 IP를 이용해서 통신하는 방법
  2. 도커 네트워크를 생성하고 컨테이너에 같은 네트워크를 추가하는 방법



### 도커 컴포즈 

- 도커 빌드와 실행에 관련된 긴 명령어를 작성하는 것은 꽤나 불편함. 게다가 다중 컨테이너의 경우 더욱 그럼

- 따라서 컴포즈는 미리 실행환경과 구성을 .yaml을 통해 정의하여 다중 컨테이너 환경을 쉽게 실행할 수 있도록 도와줌.

#### 1. 도커 컴포즈 실행

`docker-compose up`

- 이미지를 빌드하고, 모든 컨테이너를 실행함.

#### 2. 도커 컴포즈 중지

`docker-compose down`

- 모든 컨테이너를 중지함.



### 로컬(Development) vs 리모트(Production)

- 개발과 재현 가능하고 격리된 개발환경을 위한 로컬 머신 영역과 
- 애플리케이션 배포를 위한 리모트 환경



### 배포(Deployment)

- 컨테이너화된 애플리케이션의 배포

**배포시 주의사항**

- 바인드 마운트가 아닌 볼륨과, COPY 명령을 사용으로 대체할것
- 다중 컨테이너가 여러가지 호스트를 필요로 할 수 있음에 주의 
  - 여러 호스트간의 설정 필요할 수 있음. 
- 멀티 스테이지 빌드 
  - 빌드 단계를 요구하는 컨테이너의 경우 빌드과정에서 이미지를 최적화 할 수 있음. 
  - 이미지 내에 빌드 단계를 포함, 시작될때 빌드 단계 후 필요한 결과물이 있는 컨테이너를 획득 가능
- 모든 권한과 편리성과의 트레이드 오프 관계를 주의
  - 서버 직접관리 
  - 관리형 솔루션 사용 





## 쿠버네티스

- 도커 배포와 관련된 매우 구체적인 방법에 대해 설명 
- 쿠버네티스는 추가 도구, 프레임워크, 컨셉, 표준이라 할 수 있음. 
- 궁극적으로 쿠버네티스를 사용하여, 컨테이너를 실제 클라우드 배포 환경에 배치하는 방법을 배우게 됨.



### 도커로 배포시 문제점

- 도커 컨테이너를 수동으로 배포할 때 (예시로 EC2 환경), 몇 가지 문제가 발생
  - 컨테이너가 충돌하거나, 다운될 수 있으며 교체되어야할 요구 상항이 생긴다.
    - 수동으로 모니터링하고 교체하는 작업은 매우 힘듦
  - 트래픽 증가에 대해 더 많은 인스턴스가 요구되는 상황이 생긴다.
    - 이를 직접하기는 어렵다. 
  - 트래픽을 균등하게 분배해야하는 요구 상황이 생긴다.



쿠버네티스는 이러한 문제들을 해결해 줄 수 있다. 

### 왜 쿠버네티스?

- 위의 문제는 사실 AWS의 다른 솔루션을 통해서도 해결이 가능함. 
  - ECS health check, update
  - Autoscaling
  - Load Balancer
- 그러나 해당 벤더와 해당 서비스에 종속적이게 됨.
  - 벤더마다 가진 규칙과 개념이 다르기 때문에
  - 다른 벤더로 변경이 쉽지 않음.
  - 다시 학습해야함..



### 쿠버네티스란?

- 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하기 위한 오픈 소스 시스템
- 쿠버네티스로 배포하는 방식, 컨테이너 스케일링, 컨테이너가 실패할 경우 모니터링하는 방법, 교체하는 방법을 정의할 수 있기 때문.



쿠버네티스 구성

- 이 구성을 바탕으로 클라우드 벤더 혹은 원격 머신에 적용할 수 있다. 



> 배포를 설명하는 표준화된 방식을 제공하는 것! 쿠버네티스의 중요 아이디어



- 쿠버네티스는 클라우드 벤더가 아니다.
  - 오픈 소스 시스템, 벤더들과 같이 사용될 수 있는.
- 쿠버네티스트 클라우드 솔루션이 아니다.
  - 자체 머신에서도 사용할 수 있고, 다른 클라우드 벤더에서도 사용할 수 있다.
- 특정 클라우드 벤더에 종속적이지 않다.
- 머신에서 실행되는 단순 소프트웨어가 아니다?
  - 컨셉과 도구들의 집합체 
- 도커의 대안이 아니다. 
  - 도커와 같이 작동(컨테이너)
- 유료 서비스가 아니다. 



> 쿠버네티스틑 일종의 멀티 머신을 위한 도커 컴포즈와 비슷하다.

- 다중 머신 환경에서 도커화되고 컨테이너화된 애플리케이션을 관리하고 실행하기 위한 편리한 기능이 있는 도구 



### 쿠버네티스 아키텍쳐 & 핵심 컨셉

![](https://www.redhat.com/rhdc/managed-files/kubernetes_diagram-v3-770x717_0.svg)

출처 : https://www.redhat.com/ko/topics/containers/kubernetes-architecture



#### 포드 

- 쿠버네티스에서 가장 작은 기본 단위.
- 컨테이너를 보유, 컨테이너를 실행할 책임을 가짐.

#### 프록시 

- 워커 노드에서 포드 네트워크 트래픽 제어를 설정하는 도구
- 기본적으로 포드가 인터넷에 연결할 수 있는지 여부와 포드 및 그 내부에서 실행되는 컨테이너를 외부세계에서 어떻게 접근할 수 있는지를 제어.

#### 워커 노드(가상머신 :N)

- 포드가 실행되는 환경 
- 워커노드를 일종의 물리적인 머신 혹은 가상 인스턴스라고 생각할 수 있음. 
- 기본적으로 하나 이상의 워커 노드가 존재해야함.
- 컨테이너 및 포드의 동적 추가상황시 : 트래픽이 증가할 때 쿠버네티스에 의해 사용가능한 워커노드에 포드들이 자동 배포됨.

#### 마스터 노드(가상머신 :1)

- 마스터 노드에 있는 **컨트롤 플레인**에 의해 포드의 배포등을 수행함.
  - 컨트롤 플레인은 워커노드와 상호 작용하여 제어하는 컨트롤 센터임.
  - 컨트롤 플레인은 마스터 노드에서 실행되는 워커노드를 관리하기 위한 다양한 서비스의 도구 모음.
  - 워커노드와 워커노드에서 실행중인 포드와 상호작용하는 책임을 가짐.
- 일반적으로 워커노드 or 포드와 직접 상호작용하지는 않음.
- 일반적으로 마스터 노드는 단순히 다른 서버, 다른 리모트 머신임.
- 워커 노드가 다운되어도 마스터 노드는 영향을 받지 않음. 

#### 클러스터 

- 위의 모든 구성요소들을 클러스터라고 칭함.
- 하나의 네트워크를 형성
- 배포 혹은 원하는 최종상태를 노드들을(워커, 마스터 등) 구성하는 모든 것의 집합.

#### 서비스

- 고유한 포드와 컨테이너에 독립적인 IP 주소를 가진  논리적인 포드 그룹



### 쿠버네티스는 인프라를 관리하지 않는다

#### 쿠버네티스가 필요로 하는 것

- 클러스터를 생성하고 노드 인스턴스를 생성하는 일 
  - 쿠버네티스가 이를 대신해주진 않는다.
- API 서버를 설정하고, 기타 쿠버네티스 서비스를 노드에 설치하는 일 
- 필요한 다른 클라우드 벤더의 리소스(로드벨런스, 파일시스템)를 생성하는 일



#### 쿠버네티스가 하는일

- 포드를 생성하고 관리하는 일 
- 포드를 모니터링하고, 재생성, 스케일링 등
- 설정을 적용하기 위해 클라우드 벤더들의 리소스(로드벨런스, 파일시스템)를 관리



### 워커노드 (Worker Node)

- 워커노드는 단순히 머신, 컴퓨터, 인스턴스에 대응되는 개념 

- 마스터 노드에 의해 관리된다.

- 워커노드 내부에 **pod**가 존재한다.

  - 포드는 하나 이상의 애플리케이션 컨테이너와 컨테이너에 속한 리소스(구성, 볼륨 등)를 호스팅함. 
  - 포드는 쿠버네티스에 의해 생성되고 관리됨.
  - 포드안에 하나 이상의 컨테이너를 가질 수 있음.

- 주어진 워커 노드에 둘 이상의 포드가 실행되는 것이 일반적임

  - 실행되는 포드는 서로 달라도 상관 없음.

- 워커 노드에는 **docker**가 설치되어야 함. 

- 워커 노드와 마스터 노드간 통신 장치인 **kublet**도 필요함.

- 워커 노드에는 **kube-proxy**가 있으며, 들어오고 나가는 트래픽을 처리함.

  

### 마스터노드 (Master Node)

- 마스터 노드에서 가장 중요한 소프트웨어는 **API 서버 kube-apiserver**임.
  - 워커노드에서 실행되는 kublet서비스에 대한 카운터(대응자) 포인트 
  - kube-apiserver(master) : kublet(worker)
- **kube-scheduler** 는 기본적으로 포드를 관찰하고 새포드가 생성되어야 하는 워커노드를 선택하는 일을 담당하는 스케쥴러
  - 포드가 비정상이거나, 다운되었거나, 스케쥴링으로 인해 새로운 포드를 생성해야 할 때
  - 워커노드에게 어떤 것을 지시해야하는지를 API 서버에 알리는 역할 
- **kube-controller-manager** 는 워커노드 전체를 감시하고 관리함.
  - 적당한 수의 포드를 가동 중에 있는지 확인하는 역할을 함.
  - 스케쥴러와 API 서버와 긴밀하게 연동
- **clude-controller-manager** 는 동일한 역할을 하지만 클라우드 벤더들에 따라 다름
  - 일종의 클라우드 벤더 인터페이스



# 함께 이야기하고 싶은 점

- 드디어 도커의 마무리와 쿠버네티스의 시작
- 쿠버네티스가 아직은 추상적인 느낌. 