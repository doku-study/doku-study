# 도커 요약

## 이미지&컨테이너

컨테이너 : 

* 코드와 그 코드를 실행하는데 필요한 환경을 포함하는 격리된 박스
* 기본적으로 하나의 컨테이너는 하나의 일만 함
* 공유, 재생산이 쉬운 작고 가벼운 패키지를 갖는 것이 목표
* 컨테이너의 데이터는 컨테이너가 제거될 때 삭제되므로, 컨테이너는 상태를 갖지 않는다고 할 수 있다. (stateless)

이미지 :

* 컨테이너의 블루프린트
* 코드와 환경 포함
* 읽기 전용. 따라서 이미지 자체를 실행할 순 없음
* 빌드되고 공유될 수 있음
* 명령 구문들(layers)에 의해 생성됨



<br />

## 주요 명령어

`docker build` : Dockerfile 을 토대로 이미지를 빌드한다.

`docker run` : 이미지를 토대로 컨테이너를 실행한다.

`docker push` : 이미지를 도커hub 에 업로드

`docker pull` : 도커hub 로부터 이미지 다운로드



<br />

## 데이터, 볼륨 및 네트워킹

바인드 마운트 :

* 로컬 호스트 머신의 특정 경로와 컨테이너 내부의 특정 경로를 연동할 때 사용
* 주로 개발 단계에서만 쓰인다.

볼륨 :

* 컨테이너에서 생성한 데이터를 컨테이너 제거 후에도 보관하고 싶을 때 사용.
* 볼륨 데이터 자체는 로컬 호스트에 저장되나, 정확한 경로는 알 수 없다.



네트워킹 : 

* 컨테이너 <-> 외부 네트워크 : 기본적으로 지원
* 컨테이너 <-> 컨테이너 : 하나의 도커 네트워크에 속하게 하여 컨테이너 이름으로 통신



<br />



## 도커 컴포즈

여러 컨테이너를 빌드, 실행하고, 중지하는 명령어를 작성하는 것은 명령어의 길이와 반복 작업으로 인해 휴먼 에러가 일어날 확률이 높음

따라서 .yaml 파일에 명시된 설정을 통해 여러 컨테이너를 빌드하고 실행하는 과정을 간소화해줌.



<br />



## 로컬 VS 리모트

리모트 환경에서 도커를 사용하는 것의 장점

* 격리, 캡슐화, 재생산 가능한 환경을 제공함
* 컨테이너를 대체하기만 하면 되므로 업데이트가 쉬움



로컬 환경에서 도커를 사용하는 것의 장점

* 격리, 캡슐화, 재생산 가능한 환경을 제공함
* 서로 다른 프로젝트들에 대한 격리된 환경을 구성할 수 있음.
* 프로젝트를 위한 글로벌 툴을 설치할 필요가 없음. (via 유틸리티 컨테이너)
* 공유와 재생산이 쉬움



<br />

## 컨테이너를 배포할 때 주의할점

* 꼭 바인드마운트를 COPY 나 Volumes 로 대체할 것
* 애플리케이션에 따라, 여러 컨테이너는 여러 호스트가 필요할 수 있음에 주의할 것
* 빌드 단계가 필요한 앱 (ex : React) 을 구성할 때는 멀티 스테이지 빌드가 도움이 될 수 있음.
* 통제와 위임 사이의 트레이드 오프에 대해 항상 고민해볼 것.


<br />


## 컨테이너를 수동 배포하는 것의 문제점

서비스를 모니터링하고 있다가 아래의 문제들이 생겼을 때 컨테이너를 수동으로 배포하기는 귀찮다.

* 컨테이너는 충돌이 생겨서 중지될 수 있다. 
* 트래픽이 급증하면 컨테이너가 더 필요할 수도 있다.
* 유입 트래픽이 여러 컨테이너에 대해 균등하게 분배되어야 한다.



이러한 문제들을 앞 섹션에서는 ECS 를 통해 해결해왔다.

* 컨테이너는 충돌이 생겨서 중지될 수 있다.  => 컨테이너 health check + 자동 재배포
* 트래픽이 급증하면 컨테이너가 더 필요할 수도 있다. => 오토 스케일링
* 유입 트래픽이 여러 컨테이너에 대해 균등하게 분배되어야 한다. => 로드 밸런서



이러한 관리형 서비스를 이용하는 것은 분명 편리하지만, 특정 서비스 프로바이더에 묶여야 한다는 점이 단점이다.

쿠버네티스를 활용하면 이 단점을 극복할 수 있다.

<br />

# 쿠버네티스 시작하기

<br />

## 쿠버네티스

멀티 컨테이너 배포를 조율(orchestrating)하는 방법에 대한 표준 시스템

* 자동 배포
* 스케일링 & 로드 밸런싱
* 관리



쿠버네티스가 아닌 것들

* 클라우드 서비스 프로바이더?  => 오픈 소스 프로젝트임
* 클라우드 서비스 프로바이더의 제품 중 하나? => 어느 프로바이더에든 적용할 수 있음
* 특정 클라우드 서비스 프로바이더에서만 사용 가능? => 어느 프로바이더에든 적용할 수 있음
* 소프트웨어? => 개념과 툴들의 조합
* 도커의 대체재? => 도커와 함께 사용함
* 유료 ? => 무료 오픈소스 프로젝트임



쿠버네티스는 배포용 docker-compose 와 비슷한 개념이라고 생각하면 됨.



<br />



## 쿠버네티스 핵심 용어



### Pod

* 내부에 최소 하나의 컨테이너를 보유하고 있는, 쿠버네티스의 가장 작은 단위.
* 보유하고 있는 컨테이너를 실행하는 책임을 갖는다.
* 여러 팟이 애플리케이션의 스케일링을 위해 생성되고, 제거될 수 있다.
* 워커 노드 내부에 자리한다.


### Nodes

* 머신(컴퓨터)을 나타냄. (ex : 로컬 호스트 머신 또는 클라우드의 가상 인스턴스)

### Worker Nodes

* 내부에 Pod 을 보유하고, 애플리케이션의 컨테이너를 실행한다.

### Proxy (kube-proxy)

* 워커 노드의 팟 네트워크 트래픽의 제어를 설정하는 도구.
* 팟 혹은 팟 내부에서 실행되는 컨테이너를 외부 세계에서 어떻게 접근할 수 있는지를 제어함.
* 워커 노드 내부에 자리한다.

### Kublet

* 마스터 노드와 워커 노드의 커뮤니케이션에 대한 책임을 갖는다.

* 워커 노드의 내부에 자리한다.

### Master Node

* 내부적으로 Control Plane 이라는 것을 가지고 있다.
* Control Plane은 마스터 노드에서 실행되는 다양한 서비스의 다양한 도구 모음
* 여러 워커 노드들을 컨트롤한다.
* 워커노드 내부에서 실행되는 팟과 상호작용하는 책임을 가진다.

### Cluster

* 위의 객체들을 모두 포함하고 있는 환경.
* 하나의 클러스터는 Cloud Provider API 에 제공된다.
* 쿠버네티스는 클러스터를 생성하지 않고, 그저 사용할 뿐이라는 점을 유의



<br />

## 쿠버네티스가 하는 일 / 하지 않는 일

| 쿠버네티스                         | 개발자                                                       |
| ---------------------------------- | ------------------------------------------------------------ |
| 오브젝트 (ex: pod) 생성, 및 관리   | 클러스터 및 노드 인스턴스 생성 (Worker + Master Nodes)       |
| 팟 모니터링 및 재생성, 스케일링 등 | API 서버, kublet, 쿠버네티스 서비스, 노드의 소프트웨어들 설정 |
| 주어진 리소스를 목적을 위해 사용함 | 필요할 수도 있는 프로바이더 리소스들 생성 (ex: 로드밸런서, 파일시스템) |

